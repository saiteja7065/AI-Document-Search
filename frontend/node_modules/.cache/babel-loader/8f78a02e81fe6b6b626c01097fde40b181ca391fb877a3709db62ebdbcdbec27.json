{"ast":null,"code":"// Mock API service for document search and related operations\nimport { getAllDocuments, getUserDocuments, getDocumentById } from './storageService';\n\n// Mock processing delay\nconst simulateProcessingDelay = async (minMs = 500, maxMs = 1500) => {\n  const delay = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;\n  await new Promise(resolve => setTimeout(resolve, delay));\n};\n\n/**\r\n * Search documents based on query\r\n * @param {string} query - The search query\r\n * @param {Object} options - Search options \r\n * @returns {Promise<Array>} - List of matching documents with relevance scores\r\n */\nexport const searchDocuments = async (query, options = {}) => {\n  const {\n    userId,\n    limit = 10,\n    filters = {}\n  } = options;\n  await simulateProcessingDelay(800, 2000); // Simulate search processing\n\n  // Get documents (all or user-specific)\n  const documents = userId ? await getUserDocuments(userId) : await getAllDocuments();\n  if (!query || !query.trim()) {\n    return documents.slice(0, limit);\n  }\n\n  // Simple search algorithm: check if query appears in title or description\n  // In a real app, this would use vector embeddings and semantic search\n  const results = documents.map(doc => {\n    // Calculate a mock similarity score\n    const titleMatch = (doc.title || '').toLowerCase().includes(query.toLowerCase());\n    const descMatch = (doc.description || '').toLowerCase().includes(query.toLowerCase());\n    let similarityScore = 0;\n    if (titleMatch) similarityScore += 0.6;\n    if (descMatch) similarityScore += 0.4;\n\n    // Add some randomness for variety\n    similarityScore = Math.min(0.99, similarityScore + Math.random() * 0.3);\n\n    // Create a snippet with highlighted match\n    let snippet = doc.description || '';\n    if (snippet && query.length > 0) {\n      const lowerSnippet = snippet.toLowerCase();\n      const lowerQuery = query.toLowerCase();\n      const matchIndex = lowerSnippet.indexOf(lowerQuery);\n      if (matchIndex >= 0) {\n        // Extract context around the match\n        const start = Math.max(0, matchIndex - 40);\n        const end = Math.min(snippet.length, matchIndex + query.length + 40);\n        snippet = (start > 0 ? '...' : '') + snippet.slice(start, end) + (end < snippet.length ? '...' : '');\n      }\n    }\n    return {\n      document_id: doc.id,\n      title: doc.title,\n      file_type: doc.fileType,\n      similarity_score: similarityScore,\n      snippet: snippet || 'No preview available',\n      uploaded_at: doc.uploadedAt,\n      file_url: doc.fileUrl\n    };\n  }).filter(result => result.similarity_score > 0).sort((a, b) => b.similarity_score - a.similarity_score).slice(0, limit);\n  return results;\n};\n\n/**\r\n * Get a document by ID\r\n * @param {string} documentId - The document ID\r\n * @returns {Promise<Object>} - Document object\r\n */\nexport const getDocument = async documentId => {\n  await simulateProcessingDelay(300, 800);\n  return getDocumentById(documentId);\n};\n\n/**\r\n * Generate a summary of a document\r\n * @param {string} documentId - The document ID\r\n * @param {string} summaryType - Type of summary (general, key_points, detailed)\r\n * @param {number} maxLength - Maximum summary length\r\n * @returns {Promise<Object>} - Summary object\r\n */\nexport const getDocumentSummary = async (documentId, summaryType = 'general', maxLength = 500) => {\n  // Longer processing time for summaries\n  await simulateProcessingDelay(1500, 3000);\n  const document = await getDocumentById(documentId);\n  if (!document) {\n    throw new Error('Document not found');\n  }\n\n  // Generate different mock summaries based on type\n  let summary = '';\n  const title = document.title;\n  const fileType = document.fileType;\n  switch (summaryType) {\n    case 'key_points':\n      summary = `Key points from \"${title}\":\\n\\n` + `• This ${fileType.toUpperCase()} document focuses on important business information.\\n` + `• It contains critical data that can be used for decision making.\\n` + `• The document was uploaded on ${new Date(document.uploadedAt).toLocaleDateString()}.\\n` + `• Several sections discuss strategies and implementation details.\\n` + `• Contains references to related documents and resources.`;\n      break;\n    case 'detailed':\n      summary = `Detailed Summary of \"${title}\"\\n\\n` + `This ${fileType.toUpperCase()} document (${(document.fileSize / (1024 * 1024)).toFixed(2)} MB) provides comprehensive information about the subject matter. ` + `The document begins with an introduction to the topic, followed by several sections that delve into specific aspects.\\n\\n` + `The first section outlines the background and context, establishing the foundation for understanding the subsequent content. ` + `Following this, the document presents detailed analysis of various factors and considerations relevant to the topic.\\n\\n` + `Notably, the document includes statistical data, charts, and references to external sources that support its claims and findings. ` + `The conclusion summarizes the key takeaways and suggests potential next steps or areas for further exploration.\\n\\n` + `This document would be particularly useful for stakeholders involved in decision-making processes related to the subject matter.`;\n      break;\n    default:\n      // general\n      summary = `Summary of \"${title}\"\\n\\n` + `This ${fileType.toUpperCase()} document provides information about ${title.toLowerCase().includes('report') ? 'reporting and analysis' : 'the specified topic'}. ` + `It contains approximately ${Math.round(document.fileSize / 1000)} KB of data uploaded on ${new Date(document.uploadedAt).toLocaleDateString()}. ` + `The document covers several important aspects related to the subject matter and presents information in a structured format. ` + `It would be beneficial to review the complete document for comprehensive understanding.`;\n  }\n\n  // Limit summary length if needed\n  if (maxLength > 0 && summary.length > maxLength) {\n    summary = summary.substring(0, maxLength) + '...';\n  }\n  return {\n    document_id: documentId,\n    title: document.title,\n    summary_type: summaryType,\n    summary,\n    generated_at: new Date().toISOString()\n  };\n};\n\n/**\r\n * Ask a question about a document (RAG implementation)\r\n * @param {string} documentId - The document ID\r\n * @param {string} question - User question\r\n * @returns {Promise<Object>} - Answer object\r\n */\nexport const askDocumentQuestion = async (documentId, question) => {\n  // Simulate RAG processing time\n  await simulateProcessingDelay(2000, 4000);\n  const document = await getDocumentById(documentId);\n  if (!document) {\n    throw new Error('Document not found');\n  }\n\n  // Mock answers based on question types\n  let answer = '';\n  if (question.toLowerCase().includes('about') || question.toLowerCase().includes('what is')) {\n    answer = `This document titled \"${document.title}\" is a ${document.fileType.toUpperCase()} file that contains information about ${document.title.split(':')[0]}. It was uploaded on ${new Date(document.uploadedAt).toLocaleDateString()} and is approximately ${(document.fileSize / (1024 * 1024)).toFixed(2)} MB in size.`;\n  } else if (question.toLowerCase().includes('when') || question.toLowerCase().includes('date')) {\n    answer = `The document was uploaded on ${new Date(document.uploadedAt).toLocaleDateString()}.`;\n  } else if (question.toLowerCase().includes('who') || question.toLowerCase().includes('author')) {\n    answer = `The document was uploaded by a user with ID ${document.uploadedBy}. No specific author information is available in the metadata.`;\n  } else if (question.toLowerCase().includes('how') || question.toLowerCase().includes('process')) {\n    answer = `The document explains several processes related to ${document.title}. It outlines steps for implementation and provides guidelines for best practices.`;\n  } else {\n    answer = `Based on the document \"${document.title}\", I can tell you that it contains information relevant to your question. The document discusses various aspects related to ${document.title.split(':')[0]} and provides detailed insights on the matter.`;\n  }\n  return {\n    document_id: documentId,\n    question,\n    answer,\n    confidence: 0.85 + Math.random() * 0.1,\n    generated_at: new Date().toISOString()\n  };\n};\n\n/**\r\n * Get related documents\r\n * @param {string} documentId - The document ID to find related docs for\r\n * @param {number} limit - Maximum number of results\r\n * @returns {Promise<Array>} - List of related documents\r\n */\nexport const getRelatedDocuments = async (documentId, limit = 3) => {\n  await simulateProcessingDelay(800, 1500);\n  const document = await getDocumentById(documentId);\n  if (!document) {\n    throw new Error('Document not found');\n  }\n\n  // Get all documents\n  const allDocuments = await getAllDocuments();\n\n  // Filter out the current document\n  const otherDocuments = allDocuments.filter(doc => doc.id !== documentId);\n\n  // Calculate relatedness score (mock implementation)\n  const relatedDocs = otherDocuments.map(doc => {\n    // Simple mock algorithm - match words in titles\n    const words1 = document.title.toLowerCase().split(/\\W+/);\n    const words2 = doc.title.toLowerCase().split(/\\W+/);\n\n    // Count matching words\n    const matchingWords = words1.filter(word => words2.includes(word) && word.length > 3);\n\n    // Calculate score based on matching words and file type\n    let score = matchingWords.length * 0.15;\n\n    // Same file type bonus\n    if (doc.fileType === document.fileType) {\n      score += 0.2;\n    }\n\n    // Add randomness for variety\n    score = Math.min(0.95, score + Math.random() * 0.4);\n    return {\n      ...doc,\n      relatedness_score: score\n    };\n  });\n\n  // Sort by relatedness and limit results\n  return relatedDocs.filter(doc => doc.relatedness_score > 0.3) // Only include somewhat related docs\n  .sort((a, b) => b.relatedness_score - a.relatedness_score).slice(0, limit);\n};\n\n/**\r\n * Get user activity (for dashboard)\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Object>} - User activity data\r\n */\nexport const getUserActivity = async userId => {\n  await simulateProcessingDelay(500, 1000);\n\n  // Mock user activity data\n  return {\n    recent_searches: [{\n      query: \"project proposal\",\n      timestamp: new Date(Date.now() - 1000 * 60 * 60 * 2).toISOString(),\n      results: 4\n    }, {\n      query: \"financial report\",\n      timestamp: new Date(Date.now() - 1000 * 60 * 60 * 24).toISOString(),\n      results: 2\n    }, {\n      query: \"meeting notes\",\n      timestamp: new Date(Date.now() - 1000 * 60 * 60 * 72).toISOString(),\n      results: 5\n    }],\n    recent_uploads: await getUserDocuments(userId).then(docs => docs.sort((a, b) => new Date(b.uploadedAt) - new Date(a.uploadedAt)).slice(0, 5)),\n    stats: {\n      total_documents: (await getUserDocuments(userId)).length,\n      total_searches: 12,\n      total_storage_used: (await getUserDocuments(userId)).reduce((total, doc) => total + (doc.fileSize || 0), 0) / (1024 * 1024),\n      // in MB\n      documents_by_type: {\n        pdf: (await getUserDocuments(userId)).filter(doc => doc.fileType === 'pdf').length,\n        docx: (await getUserDocuments(userId)).filter(doc => doc.fileType === 'docx').length,\n        txt: (await getUserDocuments(userId)).filter(doc => doc.fileType === 'txt').length\n      }\n    }\n  };\n};\nexport default {\n  searchDocuments,\n  getDocument,\n  getDocumentSummary,\n  askDocumentQuestion,\n  getRelatedDocuments,\n  getUserActivity\n};","map":{"version":3,"names":["getAllDocuments","getUserDocuments","getDocumentById","simulateProcessingDelay","minMs","maxMs","delay","Math","floor","random","Promise","resolve","setTimeout","searchDocuments","query","options","userId","limit","filters","documents","trim","slice","results","map","doc","titleMatch","title","toLowerCase","includes","descMatch","description","similarityScore","min","snippet","length","lowerSnippet","lowerQuery","matchIndex","indexOf","start","max","end","document_id","id","file_type","fileType","similarity_score","uploaded_at","uploadedAt","file_url","fileUrl","filter","result","sort","a","b","getDocument","documentId","getDocumentSummary","summaryType","maxLength","document","Error","summary","toUpperCase","Date","toLocaleDateString","fileSize","toFixed","round","substring","summary_type","generated_at","toISOString","askDocumentQuestion","question","answer","split","uploadedBy","confidence","getRelatedDocuments","allDocuments","otherDocuments","relatedDocs","words1","words2","matchingWords","word","score","relatedness_score","getUserActivity","recent_searches","timestamp","now","recent_uploads","then","docs","stats","total_documents","total_searches","total_storage_used","reduce","total","documents_by_type","pdf","docx","txt"],"sources":["E:/FULL STACK/AI Document Search/frontend/src/services/api.js"],"sourcesContent":["// Mock API service for document search and related operations\r\nimport { getAllDocuments, getUserDocuments, getDocumentById } from './storageService';\r\n\r\n// Mock processing delay\r\nconst simulateProcessingDelay = async (minMs = 500, maxMs = 1500) => {\r\n  const delay = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;\r\n  await new Promise(resolve => setTimeout(resolve, delay));\r\n};\r\n\r\n/**\r\n * Search documents based on query\r\n * @param {string} query - The search query\r\n * @param {Object} options - Search options \r\n * @returns {Promise<Array>} - List of matching documents with relevance scores\r\n */\r\nexport const searchDocuments = async (query, options = {}) => {\r\n  const { userId, limit = 10, filters = {} } = options;\r\n  \r\n  await simulateProcessingDelay(800, 2000); // Simulate search processing\r\n  \r\n  // Get documents (all or user-specific)\r\n  const documents = userId \r\n    ? await getUserDocuments(userId)\r\n    : await getAllDocuments();\r\n  \r\n  if (!query || !query.trim()) {\r\n    return documents.slice(0, limit);\r\n  }\r\n  \r\n  // Simple search algorithm: check if query appears in title or description\r\n  // In a real app, this would use vector embeddings and semantic search\r\n  const results = documents\r\n    .map(doc => {\r\n      // Calculate a mock similarity score\r\n      const titleMatch = (doc.title || '').toLowerCase().includes(query.toLowerCase());\r\n      const descMatch = (doc.description || '').toLowerCase().includes(query.toLowerCase());\r\n      \r\n      let similarityScore = 0;\r\n      if (titleMatch) similarityScore += 0.6;\r\n      if (descMatch) similarityScore += 0.4;\r\n      \r\n      // Add some randomness for variety\r\n      similarityScore = Math.min(0.99, similarityScore + Math.random() * 0.3);\r\n      \r\n      // Create a snippet with highlighted match\r\n      let snippet = doc.description || '';\r\n      if (snippet && query.length > 0) {\r\n        const lowerSnippet = snippet.toLowerCase();\r\n        const lowerQuery = query.toLowerCase();\r\n        const matchIndex = lowerSnippet.indexOf(lowerQuery);\r\n        \r\n        if (matchIndex >= 0) {\r\n          // Extract context around the match\r\n          const start = Math.max(0, matchIndex - 40);\r\n          const end = Math.min(snippet.length, matchIndex + query.length + 40);\r\n          snippet = (start > 0 ? '...' : '') + \r\n                    snippet.slice(start, end) + \r\n                    (end < snippet.length ? '...' : '');\r\n        }\r\n      }\r\n      \r\n      return {\r\n        document_id: doc.id,\r\n        title: doc.title,\r\n        file_type: doc.fileType,\r\n        similarity_score: similarityScore,\r\n        snippet: snippet || 'No preview available',\r\n        uploaded_at: doc.uploadedAt,\r\n        file_url: doc.fileUrl\r\n      };\r\n    })\r\n    .filter(result => result.similarity_score > 0)\r\n    .sort((a, b) => b.similarity_score - a.similarity_score)\r\n    .slice(0, limit);\r\n  \r\n  return results;\r\n};\r\n\r\n/**\r\n * Get a document by ID\r\n * @param {string} documentId - The document ID\r\n * @returns {Promise<Object>} - Document object\r\n */\r\nexport const getDocument = async (documentId) => {\r\n  await simulateProcessingDelay(300, 800);\r\n  return getDocumentById(documentId);\r\n};\r\n\r\n/**\r\n * Generate a summary of a document\r\n * @param {string} documentId - The document ID\r\n * @param {string} summaryType - Type of summary (general, key_points, detailed)\r\n * @param {number} maxLength - Maximum summary length\r\n * @returns {Promise<Object>} - Summary object\r\n */\r\nexport const getDocumentSummary = async (documentId, summaryType = 'general', maxLength = 500) => {\r\n  // Longer processing time for summaries\r\n  await simulateProcessingDelay(1500, 3000);\r\n  \r\n  const document = await getDocumentById(documentId);\r\n  if (!document) {\r\n    throw new Error('Document not found');\r\n  }\r\n  \r\n  // Generate different mock summaries based on type\r\n  let summary = '';\r\n  const title = document.title;\r\n  const fileType = document.fileType;\r\n  \r\n  switch (summaryType) {\r\n    case 'key_points':\r\n      summary = `Key points from \"${title}\":\\n\\n` +\r\n                `• This ${fileType.toUpperCase()} document focuses on important business information.\\n` +\r\n                `• It contains critical data that can be used for decision making.\\n` +\r\n                `• The document was uploaded on ${new Date(document.uploadedAt).toLocaleDateString()}.\\n` +\r\n                `• Several sections discuss strategies and implementation details.\\n` +\r\n                `• Contains references to related documents and resources.`;\r\n      break;\r\n    \r\n    case 'detailed':\r\n      summary = `Detailed Summary of \"${title}\"\\n\\n` +\r\n                `This ${fileType.toUpperCase()} document (${(document.fileSize / (1024 * 1024)).toFixed(2)} MB) provides comprehensive information about the subject matter. ` +\r\n                `The document begins with an introduction to the topic, followed by several sections that delve into specific aspects.\\n\\n` +\r\n                `The first section outlines the background and context, establishing the foundation for understanding the subsequent content. ` +\r\n                `Following this, the document presents detailed analysis of various factors and considerations relevant to the topic.\\n\\n` +\r\n                `Notably, the document includes statistical data, charts, and references to external sources that support its claims and findings. ` +\r\n                `The conclusion summarizes the key takeaways and suggests potential next steps or areas for further exploration.\\n\\n` +\r\n                `This document would be particularly useful for stakeholders involved in decision-making processes related to the subject matter.`;\r\n      break;\r\n    \r\n    default: // general\r\n      summary = `Summary of \"${title}\"\\n\\n` +\r\n                `This ${fileType.toUpperCase()} document provides information about ${title.toLowerCase().includes('report') ? 'reporting and analysis' : 'the specified topic'}. ` +\r\n                `It contains approximately ${Math.round(document.fileSize / 1000)} KB of data uploaded on ${new Date(document.uploadedAt).toLocaleDateString()}. ` +\r\n                `The document covers several important aspects related to the subject matter and presents information in a structured format. ` +\r\n                `It would be beneficial to review the complete document for comprehensive understanding.`;\r\n  }\r\n  \r\n  // Limit summary length if needed\r\n  if (maxLength > 0 && summary.length > maxLength) {\r\n    summary = summary.substring(0, maxLength) + '...';\r\n  }\r\n  \r\n  return {\r\n    document_id: documentId,\r\n    title: document.title,\r\n    summary_type: summaryType,\r\n    summary,\r\n    generated_at: new Date().toISOString()\r\n  };\r\n};\r\n\r\n/**\r\n * Ask a question about a document (RAG implementation)\r\n * @param {string} documentId - The document ID\r\n * @param {string} question - User question\r\n * @returns {Promise<Object>} - Answer object\r\n */\r\nexport const askDocumentQuestion = async (documentId, question) => {\r\n  // Simulate RAG processing time\r\n  await simulateProcessingDelay(2000, 4000);\r\n  \r\n  const document = await getDocumentById(documentId);\r\n  if (!document) {\r\n    throw new Error('Document not found');\r\n  }\r\n  \r\n  // Mock answers based on question types\r\n  let answer = '';\r\n  \r\n  if (question.toLowerCase().includes('about') || question.toLowerCase().includes('what is')) {\r\n    answer = `This document titled \"${document.title}\" is a ${document.fileType.toUpperCase()} file that contains information about ${document.title.split(':')[0]}. It was uploaded on ${new Date(document.uploadedAt).toLocaleDateString()} and is approximately ${(document.fileSize / (1024 * 1024)).toFixed(2)} MB in size.`;\r\n  } else if (question.toLowerCase().includes('when') || question.toLowerCase().includes('date')) {\r\n    answer = `The document was uploaded on ${new Date(document.uploadedAt).toLocaleDateString()}.`;\r\n  } else if (question.toLowerCase().includes('who') || question.toLowerCase().includes('author')) {\r\n    answer = `The document was uploaded by a user with ID ${document.uploadedBy}. No specific author information is available in the metadata.`;\r\n  } else if (question.toLowerCase().includes('how') || question.toLowerCase().includes('process')) {\r\n    answer = `The document explains several processes related to ${document.title}. It outlines steps for implementation and provides guidelines for best practices.`;\r\n  } else {\r\n    answer = `Based on the document \"${document.title}\", I can tell you that it contains information relevant to your question. The document discusses various aspects related to ${document.title.split(':')[0]} and provides detailed insights on the matter.`;\r\n  }\r\n  \r\n  return {\r\n    document_id: documentId,\r\n    question,\r\n    answer,\r\n    confidence: 0.85 + (Math.random() * 0.1),\r\n    generated_at: new Date().toISOString()\r\n  };\r\n};\r\n\r\n/**\r\n * Get related documents\r\n * @param {string} documentId - The document ID to find related docs for\r\n * @param {number} limit - Maximum number of results\r\n * @returns {Promise<Array>} - List of related documents\r\n */\r\nexport const getRelatedDocuments = async (documentId, limit = 3) => {\r\n  await simulateProcessingDelay(800, 1500);\r\n  \r\n  const document = await getDocumentById(documentId);\r\n  if (!document) {\r\n    throw new Error('Document not found');\r\n  }\r\n  \r\n  // Get all documents\r\n  const allDocuments = await getAllDocuments();\r\n  \r\n  // Filter out the current document\r\n  const otherDocuments = allDocuments.filter(doc => doc.id !== documentId);\r\n  \r\n  // Calculate relatedness score (mock implementation)\r\n  const relatedDocs = otherDocuments.map(doc => {\r\n    // Simple mock algorithm - match words in titles\r\n    const words1 = document.title.toLowerCase().split(/\\W+/);\r\n    const words2 = doc.title.toLowerCase().split(/\\W+/);\r\n    \r\n    // Count matching words\r\n    const matchingWords = words1.filter(word => words2.includes(word) && word.length > 3);\r\n    \r\n    // Calculate score based on matching words and file type\r\n    let score = matchingWords.length * 0.15;\r\n    \r\n    // Same file type bonus\r\n    if (doc.fileType === document.fileType) {\r\n      score += 0.2;\r\n    }\r\n    \r\n    // Add randomness for variety\r\n    score = Math.min(0.95, score + Math.random() * 0.4);\r\n    \r\n    return {\r\n      ...doc,\r\n      relatedness_score: score\r\n    };\r\n  });\r\n  \r\n  // Sort by relatedness and limit results\r\n  return relatedDocs\r\n    .filter(doc => doc.relatedness_score > 0.3) // Only include somewhat related docs\r\n    .sort((a, b) => b.relatedness_score - a.relatedness_score)\r\n    .slice(0, limit);\r\n};\r\n\r\n/**\r\n * Get user activity (for dashboard)\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Object>} - User activity data\r\n */\r\nexport const getUserActivity = async (userId) => {\r\n  await simulateProcessingDelay(500, 1000);\r\n  \r\n  // Mock user activity data\r\n  return {\r\n    recent_searches: [\r\n      { query: \"project proposal\", timestamp: new Date(Date.now() - 1000 * 60 * 60 * 2).toISOString(), results: 4 },\r\n      { query: \"financial report\", timestamp: new Date(Date.now() - 1000 * 60 * 60 * 24).toISOString(), results: 2 },\r\n      { query: \"meeting notes\", timestamp: new Date(Date.now() - 1000 * 60 * 60 * 72).toISOString(), results: 5 }\r\n    ],\r\n    recent_uploads: await getUserDocuments(userId).then(docs => \r\n      docs.sort((a, b) => new Date(b.uploadedAt) - new Date(a.uploadedAt)).slice(0, 5)\r\n    ),\r\n    stats: {\r\n      total_documents: (await getUserDocuments(userId)).length,\r\n      total_searches: 12,\r\n      total_storage_used: (await getUserDocuments(userId))\r\n        .reduce((total, doc) => total + (doc.fileSize || 0), 0) / (1024 * 1024), // in MB\r\n      documents_by_type: {\r\n        pdf: (await getUserDocuments(userId)).filter(doc => doc.fileType === 'pdf').length,\r\n        docx: (await getUserDocuments(userId)).filter(doc => doc.fileType === 'docx').length,\r\n        txt: (await getUserDocuments(userId)).filter(doc => doc.fileType === 'txt').length\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\nexport default {\r\n  searchDocuments,\r\n  getDocument,\r\n  getDocumentSummary,\r\n  askDocumentQuestion,\r\n  getRelatedDocuments,\r\n  getUserActivity\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}