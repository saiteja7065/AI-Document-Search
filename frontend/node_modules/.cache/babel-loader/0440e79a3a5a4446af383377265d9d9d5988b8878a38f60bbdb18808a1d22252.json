{"ast":null,"code":"import { getStorage, ref, uploadBytesResumable, getDownloadURL, deleteObject, listAll } from 'firebase/storage';\nimport { getFirestore, collection, addDoc, deleteDoc, doc, updateDoc, getDoc, getDocs, query, where, orderBy } from 'firebase/firestore';\nimport { v4 as uuidv4 } from 'uuid';\n\n// Initialize Firebase Storage\nlet storage = null;\nlet firestore = null;\n\n// This would be properly initialized in a real app\ntry {\n  storage = getStorage();\n  firestore = getFirestore();\n} catch (error) {\n  console.error(\"Firebase not initialized:\", error);\n  // For demo purposes, we'll mock Firebase functionality\n}\n\n// Mock storage for testing without Firebase\nconst mockStorage = {\n  documents: [],\n  documentCounter: 0\n};\n\n/**\r\n * Upload a document to cloud storage\r\n * @param {File} file - The file to upload\r\n * @param {string} title - Document title\r\n * @param {string} userId - User ID who is uploading\r\n * @param {Function} progressCallback - Callback for upload progress\r\n * @returns {Promise<Object>} - Uploaded document metadata\r\n */\nexport const uploadDocument = async (file, title, userId, progressCallback = () => {}) => {\n  try {\n    if (!storage || !firestore) {\n      // Mock implementation for demo without Firebase\n      return mockUploadDocument(file, title, userId, progressCallback);\n    }\n\n    // Create a reference with a unique name\n    const fileId = uuidv4();\n    const fileExtension = file.name.split('.').pop();\n    const filePath = `documents/${userId}/${fileId}.${fileExtension}`;\n    const storageRef = ref(storage, filePath);\n\n    // Upload the file\n    const uploadTask = uploadBytesResumable(storageRef, file);\n\n    // Monitor upload progress\n    return new Promise((resolve, reject) => {\n      uploadTask.on('state_changed', snapshot => {\n        const progress = snapshot.bytesTransferred / snapshot.totalBytes * 100;\n        progressCallback(progress);\n      }, error => {\n        console.error('Upload error:', error);\n        reject(error);\n      }, async () => {\n        // Get download URL\n        const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);\n\n        // Add document metadata to Firestore\n        const docData = {\n          id: fileId,\n          title: title,\n          fileName: file.name,\n          fileSize: file.size,\n          fileType: fileExtension,\n          fileUrl: downloadURL,\n          uploadedBy: userId,\n          uploadedAt: new Date().toISOString(),\n          path: filePath\n        };\n\n        // Save to Firestore\n        const docRef = await addDoc(collection(firestore, 'documents'), docData);\n        resolve({\n          ...docData,\n          id: docRef.id\n        });\n      });\n    });\n  } catch (error) {\n    console.error('Error uploading document:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Get all documents for a user\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Array>} - List of documents\r\n */\nexport const getUserDocuments = async userId => {\n  try {\n    if (!firestore) {\n      // Mock implementation\n      return mockStorage.documents.filter(doc => doc.uploadedBy === userId);\n    }\n    const q = query(collection(firestore, 'documents'), where('uploadedBy', '==', userId), orderBy('uploadedAt', 'desc'));\n    const querySnapshot = await getDocs(q);\n    const documents = [];\n    querySnapshot.forEach(doc => {\n      documents.push({\n        id: doc.id,\n        ...doc.data()\n      });\n    });\n    return documents;\n  } catch (error) {\n    console.error('Error getting user documents:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Delete a document\r\n * @param {string} documentId - Document ID to delete\r\n * @param {string} filePath - Path to file in storage\r\n * @returns {Promise<boolean>} - Success status\r\n */\nexport const deleteDocument = async (documentId, filePath) => {\n  try {\n    if (!storage || !firestore) {\n      // Mock implementation\n      mockStorage.documents = mockStorage.documents.filter(doc => doc.id !== documentId);\n      return true;\n    }\n\n    // Delete from Firestore\n    await deleteDoc(doc(firestore, 'documents', documentId));\n\n    // Delete from Storage\n    if (filePath) {\n      const fileRef = ref(storage, filePath);\n      await deleteObject(fileRef);\n    }\n    return true;\n  } catch (error) {\n    console.error('Error deleting document:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Update document metadata\r\n * @param {string} documentId - Document ID to update\r\n * @param {Object} updates - Fields to update\r\n * @returns {Promise<Object>} - Updated document\r\n */\nexport const updateDocumentMetadata = async (documentId, updates) => {\n  try {\n    if (!firestore) {\n      // Mock implementation\n      const docIndex = mockStorage.documents.findIndex(doc => doc.id === documentId);\n      if (docIndex !== -1) {\n        mockStorage.documents[docIndex] = {\n          ...mockStorage.documents[docIndex],\n          ...updates\n        };\n        return mockStorage.documents[docIndex];\n      }\n      throw new Error('Document not found');\n    }\n    const docRef = doc(firestore, 'documents', documentId);\n    await updateDoc(docRef, updates);\n    const updatedDoc = await getDoc(docRef);\n    return {\n      id: updatedDoc.id,\n      ...updatedDoc.data()\n    };\n  } catch (error) {\n    console.error('Error updating document metadata:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Get all documents (Admin only)\r\n * @returns {Promise<Array>} - List of all documents\r\n */\nexport const getAllDocuments = async () => {\n  try {\n    if (!firestore) {\n      // Mock implementation\n      return mockStorage.documents;\n    }\n    const q = query(collection(firestore, 'documents'), orderBy('uploadedAt', 'desc'));\n    const querySnapshot = await getDocs(q);\n    const documents = [];\n    querySnapshot.forEach(doc => {\n      documents.push({\n        id: doc.id,\n        ...doc.data()\n      });\n    });\n    return documents;\n  } catch (error) {\n    console.error('Error getting all documents:', error);\n    throw error;\n  }\n};\n\n// Mock implementations for testing without Firebase\nconst mockUploadDocument = async (file, title, userId, progressCallback) => {\n  return new Promise(resolve => {\n    // Simulate upload progress\n    let progress = 0;\n    const progressInterval = setInterval(() => {\n      progress += 10;\n      progressCallback(progress);\n      if (progress >= 100) {\n        clearInterval(progressInterval);\n\n        // Create mock document\n        const fileExtension = file.name.split('.').pop();\n        const docId = `mock-doc-${++mockStorage.documentCounter}`;\n        const newDoc = {\n          id: docId,\n          title,\n          fileName: file.name,\n          fileSize: file.size,\n          fileType: fileExtension,\n          fileUrl: `https://mock-storage.example.com/${docId}`,\n          uploadedBy: userId,\n          uploadedAt: new Date().toISOString(),\n          path: `documents/${userId}/${docId}.${fileExtension}`\n        };\n        mockStorage.documents.push(newDoc);\n        resolve(newDoc);\n      }\n    }, 300);\n  });\n};\nexport default {\n  uploadDocument,\n  getUserDocuments,\n  deleteDocument,\n  updateDocumentMetadata,\n  getAllDocuments\n};","map":{"version":3,"names":["getStorage","ref","uploadBytesResumable","getDownloadURL","deleteObject","listAll","getFirestore","collection","addDoc","deleteDoc","doc","updateDoc","getDoc","getDocs","query","where","orderBy","v4","uuidv4","storage","firestore","error","console","mockStorage","documents","documentCounter","uploadDocument","file","title","userId","progressCallback","mockUploadDocument","fileId","fileExtension","name","split","pop","filePath","storageRef","uploadTask","Promise","resolve","reject","on","snapshot","progress","bytesTransferred","totalBytes","downloadURL","docData","id","fileName","fileSize","size","fileType","fileUrl","uploadedBy","uploadedAt","Date","toISOString","path","docRef","getUserDocuments","filter","q","querySnapshot","forEach","push","data","deleteDocument","documentId","fileRef","updateDocumentMetadata","updates","docIndex","findIndex","Error","updatedDoc","getAllDocuments","progressInterval","setInterval","clearInterval","docId","newDoc"],"sources":["E:/FULL STACK/AI Document Search/frontend/src/services/storageService.js"],"sourcesContent":["import { getStorage, ref, uploadBytesResumable, getDownloadURL, deleteObject, listAll } from 'firebase/storage';\r\nimport { getFirestore, collection, addDoc, deleteDoc, doc, updateDoc, getDoc, getDocs, query, where, orderBy } from 'firebase/firestore';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\n// Initialize Firebase Storage\r\nlet storage = null;\r\nlet firestore = null;\r\n\r\n// This would be properly initialized in a real app\r\ntry {\r\n  storage = getStorage();\r\n  firestore = getFirestore();\r\n} catch (error) {\r\n  console.error(\"Firebase not initialized:\", error);\r\n  // For demo purposes, we'll mock Firebase functionality\r\n}\r\n\r\n// Mock storage for testing without Firebase\r\nconst mockStorage = {\r\n  documents: [],\r\n  documentCounter: 0\r\n};\r\n\r\n/**\r\n * Upload a document to cloud storage\r\n * @param {File} file - The file to upload\r\n * @param {string} title - Document title\r\n * @param {string} userId - User ID who is uploading\r\n * @param {Function} progressCallback - Callback for upload progress\r\n * @returns {Promise<Object>} - Uploaded document metadata\r\n */\r\nexport const uploadDocument = async (file, title, userId, progressCallback = () => {}) => {\r\n  try {\r\n    if (!storage || !firestore) {\r\n      // Mock implementation for demo without Firebase\r\n      return mockUploadDocument(file, title, userId, progressCallback);\r\n    }\r\n\r\n    // Create a reference with a unique name\r\n    const fileId = uuidv4();\r\n    const fileExtension = file.name.split('.').pop();\r\n    const filePath = `documents/${userId}/${fileId}.${fileExtension}`;\r\n    const storageRef = ref(storage, filePath);\r\n\r\n    // Upload the file\r\n    const uploadTask = uploadBytesResumable(storageRef, file);\r\n\r\n    // Monitor upload progress\r\n    return new Promise((resolve, reject) => {\r\n      uploadTask.on(\r\n        'state_changed',\r\n        (snapshot) => {\r\n          const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;\r\n          progressCallback(progress);\r\n        },\r\n        (error) => {\r\n          console.error('Upload error:', error);\r\n          reject(error);\r\n        },\r\n        async () => {\r\n          // Get download URL\r\n          const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);\r\n\r\n          // Add document metadata to Firestore\r\n          const docData = {\r\n            id: fileId,\r\n            title: title,\r\n            fileName: file.name,\r\n            fileSize: file.size,\r\n            fileType: fileExtension,\r\n            fileUrl: downloadURL,\r\n            uploadedBy: userId,\r\n            uploadedAt: new Date().toISOString(),\r\n            path: filePath\r\n          };\r\n\r\n          // Save to Firestore\r\n          const docRef = await addDoc(collection(firestore, 'documents'), docData);\r\n          \r\n          resolve({ ...docData, id: docRef.id });\r\n        }\r\n      );\r\n    });\r\n  } catch (error) {\r\n    console.error('Error uploading document:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Get all documents for a user\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Array>} - List of documents\r\n */\r\nexport const getUserDocuments = async (userId) => {\r\n  try {\r\n    if (!firestore) {\r\n      // Mock implementation\r\n      return mockStorage.documents.filter(doc => doc.uploadedBy === userId);\r\n    }\r\n\r\n    const q = query(\r\n      collection(firestore, 'documents'),\r\n      where('uploadedBy', '==', userId),\r\n      orderBy('uploadedAt', 'desc')\r\n    );\r\n\r\n    const querySnapshot = await getDocs(q);\r\n    const documents = [];\r\n    \r\n    querySnapshot.forEach((doc) => {\r\n      documents.push({ id: doc.id, ...doc.data() });\r\n    });\r\n    \r\n    return documents;\r\n  } catch (error) {\r\n    console.error('Error getting user documents:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Delete a document\r\n * @param {string} documentId - Document ID to delete\r\n * @param {string} filePath - Path to file in storage\r\n * @returns {Promise<boolean>} - Success status\r\n */\r\nexport const deleteDocument = async (documentId, filePath) => {\r\n  try {\r\n    if (!storage || !firestore) {\r\n      // Mock implementation\r\n      mockStorage.documents = mockStorage.documents.filter(doc => doc.id !== documentId);\r\n      return true;\r\n    }\r\n\r\n    // Delete from Firestore\r\n    await deleteDoc(doc(firestore, 'documents', documentId));\r\n\r\n    // Delete from Storage\r\n    if (filePath) {\r\n      const fileRef = ref(storage, filePath);\r\n      await deleteObject(fileRef);\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error deleting document:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Update document metadata\r\n * @param {string} documentId - Document ID to update\r\n * @param {Object} updates - Fields to update\r\n * @returns {Promise<Object>} - Updated document\r\n */\r\nexport const updateDocumentMetadata = async (documentId, updates) => {\r\n  try {\r\n    if (!firestore) {\r\n      // Mock implementation\r\n      const docIndex = mockStorage.documents.findIndex(doc => doc.id === documentId);\r\n      if (docIndex !== -1) {\r\n        mockStorage.documents[docIndex] = {\r\n          ...mockStorage.documents[docIndex],\r\n          ...updates\r\n        };\r\n        return mockStorage.documents[docIndex];\r\n      }\r\n      throw new Error('Document not found');\r\n    }\r\n\r\n    const docRef = doc(firestore, 'documents', documentId);\r\n    await updateDoc(docRef, updates);\r\n    \r\n    const updatedDoc = await getDoc(docRef);\r\n    return { id: updatedDoc.id, ...updatedDoc.data() };\r\n  } catch (error) {\r\n    console.error('Error updating document metadata:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Get all documents (Admin only)\r\n * @returns {Promise<Array>} - List of all documents\r\n */\r\nexport const getAllDocuments = async () => {\r\n  try {\r\n    if (!firestore) {\r\n      // Mock implementation\r\n      return mockStorage.documents;\r\n    }\r\n\r\n    const q = query(\r\n      collection(firestore, 'documents'),\r\n      orderBy('uploadedAt', 'desc')\r\n    );\r\n\r\n    const querySnapshot = await getDocs(q);\r\n    const documents = [];\r\n    \r\n    querySnapshot.forEach((doc) => {\r\n      documents.push({ id: doc.id, ...doc.data() });\r\n    });\r\n    \r\n    return documents;\r\n  } catch (error) {\r\n    console.error('Error getting all documents:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Mock implementations for testing without Firebase\r\nconst mockUploadDocument = async (file, title, userId, progressCallback) => {\r\n  return new Promise((resolve) => {\r\n    // Simulate upload progress\r\n    let progress = 0;\r\n    const progressInterval = setInterval(() => {\r\n      progress += 10;\r\n      progressCallback(progress);\r\n      \r\n      if (progress >= 100) {\r\n        clearInterval(progressInterval);\r\n        \r\n        // Create mock document\r\n        const fileExtension = file.name.split('.').pop();\r\n        const docId = `mock-doc-${++mockStorage.documentCounter}`;\r\n        const newDoc = {\r\n          id: docId,\r\n          title,\r\n          fileName: file.name,\r\n          fileSize: file.size,\r\n          fileType: fileExtension,\r\n          fileUrl: `https://mock-storage.example.com/${docId}`,\r\n          uploadedBy: userId,\r\n          uploadedAt: new Date().toISOString(),\r\n          path: `documents/${userId}/${docId}.${fileExtension}`\r\n        };\r\n        \r\n        mockStorage.documents.push(newDoc);\r\n        resolve(newDoc);\r\n      }\r\n    }, 300);\r\n  });\r\n};\r\n\r\nexport default {\r\n  uploadDocument,\r\n  getUserDocuments,\r\n  deleteDocument,\r\n  updateDocumentMetadata,\r\n  getAllDocuments\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}