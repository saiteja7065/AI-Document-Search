{"ast":null,"code":"// Mock implementation for document storage\nimport { v4 as uuidv4 } from 'uuid';\n\n// Mock storage for testing without Firebase\nconst mockStorage = {\n  documents: [],\n  documentCounter: 0,\n  users: {\n    'user-123': {\n      name: 'Demo User',\n      email: 'demo@example.com'\n    }\n  },\n  bookmarks: [],\n  tags: [{\n    id: 'tag-1',\n    name: 'Important',\n    color: '#f44336'\n  }, {\n    id: 'tag-2',\n    name: 'Work',\n    color: '#2196f3'\n  }, {\n    id: 'tag-3',\n    name: 'Personal',\n    color: '#4caf50'\n  }, {\n    id: 'tag-4',\n    name: 'Archived',\n    color: '#9e9e9e'\n  }, {\n    id: 'tag-5',\n    name: 'Confidential',\n    color: '#ff9800'\n  }],\n  documentTags: [] // Relationship between documents and tags\n};\n\n/**\r\n * Upload a document to storage\r\n * @param {File} file - The file to upload\r\n * @param {string} title - Document title\r\n * @param {string} userId - User ID who is uploading\r\n * @param {Function} progressCallback - Callback for upload progress\r\n * @returns {Promise<Object>} - Uploaded document metadata\r\n */\nexport const uploadDocument = async (file, title, userId, progressCallback = () => {}) => {\n  return new Promise(resolve => {\n    // Simulate upload progress\n    let progress = 0;\n    const progressInterval = setInterval(() => {\n      progress += 10;\n      progressCallback(progress);\n      if (progress >= 100) {\n        clearInterval(progressInterval);\n\n        // Create mock document\n        const fileExtension = file.name.split('.').pop().toLowerCase();\n        const docId = `doc-${uuidv4()}`;\n        const newDoc = {\n          id: docId,\n          title,\n          fileName: file.name,\n          fileSize: file.size,\n          fileType: fileExtension,\n          fileUrl: URL.createObjectURL(file),\n          // Create a blob URL for the file\n          uploadedBy: userId,\n          uploadedAt: new Date().toISOString(),\n          path: `documents/${userId}/${docId}.${fileExtension}`,\n          description: `This is a ${fileExtension.toUpperCase()} document uploaded by the user.`\n        };\n        mockStorage.documents.push(newDoc);\n        resolve(newDoc);\n      }\n    }, 300);\n  });\n};\n\n/**\r\n * Get all documents for a user\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Array>} - List of documents\r\n */\nexport const getUserDocuments = async userId => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 500));\n  return mockStorage.documents.filter(doc => doc.uploadedBy === userId);\n};\n\n/**\r\n * Delete a document\r\n * @param {string} documentId - Document ID to delete\r\n * @returns {Promise<boolean>} - Success status\r\n */\nexport const deleteDocument = async documentId => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 500));\n\n  // Find and remove the document\n  const docIndex = mockStorage.documents.findIndex(doc => doc.id === documentId);\n  if (docIndex !== -1) {\n    mockStorage.documents.splice(docIndex, 1);\n\n    // Also remove from bookmarks\n    mockStorage.bookmarks = mockStorage.bookmarks.filter(bookmark => bookmark.documentId !== documentId);\n    return true;\n  }\n  return false;\n};\n\n/**\r\n * Update document metadata\r\n * @param {string} documentId - Document ID to update\r\n * @param {Object} updates - Fields to update\r\n * @returns {Promise<Object>} - Updated document\r\n */\nexport const updateDocumentMetadata = async (documentId, updates) => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 500));\n  const docIndex = mockStorage.documents.findIndex(doc => doc.id === documentId);\n  if (docIndex !== -1) {\n    // Update the document\n    mockStorage.documents[docIndex] = {\n      ...mockStorage.documents[docIndex],\n      ...updates,\n      updatedAt: new Date().toISOString()\n    };\n    return mockStorage.documents[docIndex];\n  }\n  throw new Error('Document not found');\n};\n\n/**\r\n * Get all documents (Admin only)\r\n * @returns {Promise<Array>} - List of all documents\r\n */\nexport const getAllDocuments = async () => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 500));\n  return [...mockStorage.documents].sort((a, b) => new Date(b.uploadedAt) - new Date(a.uploadedAt));\n};\n\n/**\r\n * Get a document by ID\r\n * @param {string} documentId - Document ID\r\n * @returns {Promise<Object>} - Document object\r\n */\nexport const getDocumentById = async documentId => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 500));\n  const document = mockStorage.documents.find(doc => doc.id === documentId);\n  if (!document) {\n    throw new Error('Document not found');\n  }\n  return document;\n};\n\n/**\r\n * Bookmark a document\r\n * @param {string} userId - User ID\r\n * @param {string} documentId - Document ID\r\n * @returns {Promise<Object>} - Bookmark object\r\n */\nexport const bookmarkDocument = async (userId, documentId) => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 500));\n\n  // Check if already bookmarked\n  const existingBookmark = mockStorage.bookmarks.find(b => b.userId === userId && b.documentId === documentId);\n  if (existingBookmark) {\n    return existingBookmark;\n  }\n\n  // Create new bookmark\n  const bookmark = {\n    id: `bookmark-${uuidv4()}`,\n    userId,\n    documentId,\n    createdAt: new Date().toISOString()\n  };\n  mockStorage.bookmarks.push(bookmark);\n  return bookmark;\n};\n\n/**\r\n * Remove a document bookmark\r\n * @param {string} userId - User ID\r\n * @param {string} documentId - Document ID\r\n * @returns {Promise<boolean>} - Success status\r\n */\nexport const removeBookmark = async (userId, documentId) => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 500));\n  const bookmarkIndex = mockStorage.bookmarks.findIndex(b => b.userId === userId && b.documentId === documentId);\n  if (bookmarkIndex !== -1) {\n    mockStorage.bookmarks.splice(bookmarkIndex, 1);\n    return true;\n  }\n  return false;\n};\n\n/**\r\n * Get bookmarked documents for a user\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Array>} - List of bookmarked documents\r\n */\nexport const getBookmarkedDocuments = async userId => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 500));\n\n  // Get bookmark entries for this user\n  const bookmarks = mockStorage.bookmarks.filter(b => b.userId === userId);\n\n  // Get the actual documents\n  const bookmarkedDocs = bookmarks.map(bookmark => {\n    const doc = mockStorage.documents.find(d => d.id === bookmark.documentId);\n    return doc ? {\n      ...doc,\n      bookmarkedAt: bookmark.createdAt\n    } : null;\n  }).filter(doc => doc !== null);\n  return bookmarkedDocs;\n};\n\n/**\r\n * Check if a document is bookmarked\r\n * @param {string} userId - User ID\r\n * @param {string} documentId - Document ID\r\n * @returns {Promise<boolean>} - Whether the document is bookmarked\r\n */\nexport const isDocumentBookmarked = async (userId, documentId) => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 300));\n  return mockStorage.bookmarks.some(b => b.userId === userId && b.documentId === documentId);\n};\n\n/**\r\n * Get all available tags\r\n * @returns {Promise<Array>} - List of all tags\r\n */\nexport const getAllTags = async () => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 300));\n  return [...mockStorage.tags];\n};\n\n/**\r\n * Create a new tag\r\n * @param {string} name - Tag name\r\n * @param {string} color - Tag color (hex)\r\n * @returns {Promise<Object>} - Created tag\r\n */\nexport const createTag = async (name, color = '#2196f3') => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 400));\n\n  // Check if tag with this name already exists\n  if (mockStorage.tags.some(tag => tag.name.toLowerCase() === name.toLowerCase())) {\n    throw new Error(`Tag \"${name}\" already exists`);\n  }\n  const newTag = {\n    id: `tag-${uuidv4()}`,\n    name,\n    color,\n    createdAt: new Date().toISOString()\n  };\n  mockStorage.tags.push(newTag);\n  return newTag;\n};\n\n/**\r\n * Add tags to a document\r\n * @param {string} documentId - Document ID\r\n * @param {Array<string>} tagIds - Array of tag IDs\r\n * @returns {Promise<Array>} - Updated document tags\r\n */\nexport const addTagsToDocument = async (documentId, tagIds) => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 400));\n\n  // Check if document exists\n  const documentExists = mockStorage.documents.some(doc => doc.id === documentId);\n  if (!documentExists) {\n    throw new Error('Document not found');\n  }\n\n  // Validate tag IDs\n  const validTagIds = tagIds.filter(tagId => mockStorage.tags.some(tag => tag.id === tagId));\n\n  // Add tags that don't already exist for this document\n  validTagIds.forEach(tagId => {\n    const existingRelation = mockStorage.documentTags.find(dt => dt.documentId === documentId && dt.tagId === tagId);\n    if (!existingRelation) {\n      mockStorage.documentTags.push({\n        id: `doc-tag-${uuidv4()}`,\n        documentId,\n        tagId,\n        addedAt: new Date().toISOString()\n      });\n    }\n  });\n\n  // Return all tags for this document\n  return getDocumentTags(documentId);\n};\n\n/**\r\n * Remove a tag from a document\r\n * @param {string} documentId - Document ID\r\n * @param {string} tagId - Tag ID to remove\r\n * @returns {Promise<boolean>} - Success status\r\n */\nexport const removeTagFromDocument = async (documentId, tagId) => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 300));\n  const initialLength = mockStorage.documentTags.length;\n  mockStorage.documentTags = mockStorage.documentTags.filter(dt => !(dt.documentId === documentId && dt.tagId === tagId));\n  return mockStorage.documentTags.length < initialLength;\n};\n\n/**\r\n * Get all tags for a document\r\n * @param {string} documentId - Document ID\r\n * @returns {Promise<Array>} - List of tags\r\n */\nexport const getDocumentTags = async documentId => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 300));\n\n  // Get tag IDs for this document\n  const tagIds = mockStorage.documentTags.filter(dt => dt.documentId === documentId).map(dt => dt.tagId);\n\n  // Get full tag objects\n  return mockStorage.tags.filter(tag => tagIds.includes(tag.id));\n};\n\n/**\r\n * Get all documents with a specific tag\r\n * @param {string} tagId - Tag ID\r\n * @returns {Promise<Array>} - List of documents\r\n */\nexport const getDocumentsByTag = async tagId => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 500));\n\n  // Get document IDs with this tag\n  const documentIds = mockStorage.documentTags.filter(dt => dt.tagId === tagId).map(dt => dt.documentId);\n\n  // Get full document objects\n  return mockStorage.documents.filter(doc => documentIds.includes(doc.id));\n};\n\n// Generate some initial sample data\nconst generateSampleData = () => {\n  const sampleDocs = [{\n    title: \"Company Annual Report 2023\",\n    fileType: \"pdf\",\n    description: \"Financial statements and overview of company performance for 2023.\",\n    fileSize: 2.4 * 1024 * 1024\n  }, {\n    title: \"Project Proposal: AI Integration\",\n    fileType: \"docx\",\n    description: \"Detailed proposal for integrating AI into our customer service workflows.\",\n    fileSize: 1.8 * 1024 * 1024\n  }, {\n    title: \"Meeting Notes - Product Team\",\n    fileType: \"txt\",\n    description: \"Notes from the weekly product team meeting discussing roadmap.\",\n    fileSize: 0.2 * 1024 * 1024\n  }, {\n    title: \"Technical Documentation\",\n    fileType: \"pdf\",\n    description: \"API reference and implementation guide for developers.\",\n    fileSize: 3.5 * 1024 * 1024\n  }, {\n    title: \"Marketing Strategy 2024\",\n    fileType: \"docx\",\n    description: \"Comprehensive marketing plan and strategy for the upcoming year.\",\n    fileSize: 1.2 * 1024 * 1024\n  }];\n\n  // Add sample documents\n  sampleDocs.forEach((doc, index) => {\n    const docId = `sample-doc-${index + 1}`;\n    mockStorage.documents.push({\n      id: docId,\n      title: doc.title,\n      fileName: `${doc.title.toLowerCase().replace(/\\s+/g, '-')}.${doc.fileType}`,\n      fileSize: doc.fileSize,\n      fileType: doc.fileType,\n      fileUrl: `https://example.com/documents/${docId}`,\n      uploadedBy: 'user-123',\n      uploadedAt: new Date(Date.now() - index * 86400000).toISOString(),\n      // Each doc one day apart\n      path: `documents/user-123/${docId}.${doc.fileType}`,\n      description: doc.description\n    });\n  });\n\n  // Add some bookmarks\n  mockStorage.bookmarks.push({\n    id: 'bookmark-1',\n    userId: 'user-123',\n    documentId: 'sample-doc-1',\n    createdAt: new Date().toISOString()\n  });\n  mockStorage.bookmarks.push({\n    id: 'bookmark-2',\n    userId: 'user-123',\n    documentId: 'sample-doc-3',\n    createdAt: new Date().toISOString()\n  });\n\n  // Add sample document tags\n  mockStorage.documentTags.push({\n    id: 'doc-tag-1',\n    documentId: 'sample-doc-1',\n    tagId: 'tag-1',\n    addedAt: new Date().toISOString()\n  }, {\n    id: 'doc-tag-2',\n    documentId: 'sample-doc-1',\n    tagId: 'tag-5',\n    addedAt: new Date().toISOString()\n  }, {\n    id: 'doc-tag-3',\n    documentId: 'sample-doc-2',\n    tagId: 'tag-2',\n    addedAt: new Date().toISOString()\n  }, {\n    id: 'doc-tag-4',\n    documentId: 'sample-doc-3',\n    tagId: 'tag-3',\n    addedAt: new Date().toISOString()\n  }, {\n    id: 'doc-tag-5',\n    documentId: 'sample-doc-4',\n    tagId: 'tag-2',\n    addedAt: new Date().toISOString()\n  });\n};\n\n// Initialize sample data\ngenerateSampleData();\nexport default {\n  uploadDocument,\n  getUserDocuments,\n  getDocumentById,\n  deleteDocument,\n  updateDocumentMetadata,\n  getAllDocuments,\n  bookmarkDocument,\n  removeBookmark,\n  getBookmarkedDocuments,\n  isDocumentBookmarked,\n  getAllTags,\n  createTag,\n  addTagsToDocument,\n  removeTagFromDocument,\n  getDocumentTags,\n  getDocumentsByTag\n};","map":{"version":3,"names":["v4","uuidv4","mockStorage","documents","documentCounter","users","name","email","bookmarks","tags","id","color","documentTags","uploadDocument","file","title","userId","progressCallback","Promise","resolve","progress","progressInterval","setInterval","clearInterval","fileExtension","split","pop","toLowerCase","docId","newDoc","fileName","fileSize","size","fileType","fileUrl","URL","createObjectURL","uploadedBy","uploadedAt","Date","toISOString","path","description","toUpperCase","push","getUserDocuments","setTimeout","filter","doc","deleteDocument","documentId","docIndex","findIndex","splice","bookmark","updateDocumentMetadata","updates","updatedAt","Error","getAllDocuments","sort","a","b","getDocumentById","document","find","bookmarkDocument","existingBookmark","createdAt","removeBookmark","bookmarkIndex","getBookmarkedDocuments","bookmarkedDocs","map","d","bookmarkedAt","isDocumentBookmarked","some","getAllTags","createTag","tag","newTag","addTagsToDocument","tagIds","documentExists","validTagIds","tagId","forEach","existingRelation","dt","addedAt","getDocumentTags","removeTagFromDocument","initialLength","length","includes","getDocumentsByTag","documentIds","generateSampleData","sampleDocs","index","replace","now"],"sources":["e:/FULL STACK/AI Document Search/frontend/src/services/storageService.js"],"sourcesContent":["// Mock implementation for document storage\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\n// Mock storage for testing without Firebase\r\nconst mockStorage = {\r\n  documents: [],\r\n  documentCounter: 0,\r\n  users: {\r\n    'user-123': { name: 'Demo User', email: 'demo@example.com' }\r\n  },\r\n  bookmarks: [],\r\n  tags: [\r\n    { id: 'tag-1', name: 'Important', color: '#f44336' },\r\n    { id: 'tag-2', name: 'Work', color: '#2196f3' },\r\n    { id: 'tag-3', name: 'Personal', color: '#4caf50' },\r\n    { id: 'tag-4', name: 'Archived', color: '#9e9e9e' },\r\n    { id: 'tag-5', name: 'Confidential', color: '#ff9800' }\r\n  ],\r\n  documentTags: [] // Relationship between documents and tags\r\n};\r\n\r\n/**\r\n * Upload a document to storage\r\n * @param {File} file - The file to upload\r\n * @param {string} title - Document title\r\n * @param {string} userId - User ID who is uploading\r\n * @param {Function} progressCallback - Callback for upload progress\r\n * @returns {Promise<Object>} - Uploaded document metadata\r\n */\r\nexport const uploadDocument = async (file, title, userId, progressCallback = () => {}) => {\r\n  return new Promise((resolve) => {\r\n    // Simulate upload progress\r\n    let progress = 0;\r\n    const progressInterval = setInterval(() => {\r\n      progress += 10;\r\n      progressCallback(progress);\r\n      \r\n      if (progress >= 100) {\r\n        clearInterval(progressInterval);\r\n        \r\n        // Create mock document\r\n        const fileExtension = file.name.split('.').pop().toLowerCase();\r\n        const docId = `doc-${uuidv4()}`;\r\n        const newDoc = {\r\n          id: docId,\r\n          title,\r\n          fileName: file.name,\r\n          fileSize: file.size,\r\n          fileType: fileExtension,\r\n          fileUrl: URL.createObjectURL(file), // Create a blob URL for the file\r\n          uploadedBy: userId,\r\n          uploadedAt: new Date().toISOString(),\r\n          path: `documents/${userId}/${docId}.${fileExtension}`,\r\n          description: `This is a ${fileExtension.toUpperCase()} document uploaded by the user.`\r\n        };\r\n        \r\n        mockStorage.documents.push(newDoc);\r\n        resolve(newDoc);\r\n      }\r\n    }, 300);\r\n  });\r\n};\r\n\r\n/**\r\n * Get all documents for a user\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Array>} - List of documents\r\n */\r\nexport const getUserDocuments = async (userId) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 500));\r\n  return mockStorage.documents.filter(doc => doc.uploadedBy === userId);\r\n};\r\n\r\n/**\r\n * Delete a document\r\n * @param {string} documentId - Document ID to delete\r\n * @returns {Promise<boolean>} - Success status\r\n */\r\nexport const deleteDocument = async (documentId) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 500));\r\n  \r\n  // Find and remove the document\r\n  const docIndex = mockStorage.documents.findIndex(doc => doc.id === documentId);\r\n  \r\n  if (docIndex !== -1) {\r\n    mockStorage.documents.splice(docIndex, 1);\r\n    \r\n    // Also remove from bookmarks\r\n    mockStorage.bookmarks = mockStorage.bookmarks.filter(\r\n      bookmark => bookmark.documentId !== documentId\r\n    );\r\n    \r\n    return true;\r\n  }\r\n  \r\n  return false;\r\n};\r\n\r\n/**\r\n * Update document metadata\r\n * @param {string} documentId - Document ID to update\r\n * @param {Object} updates - Fields to update\r\n * @returns {Promise<Object>} - Updated document\r\n */\r\nexport const updateDocumentMetadata = async (documentId, updates) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 500));\r\n  \r\n  const docIndex = mockStorage.documents.findIndex(doc => doc.id === documentId);\r\n  \r\n  if (docIndex !== -1) {\r\n    // Update the document\r\n    mockStorage.documents[docIndex] = {\r\n      ...mockStorage.documents[docIndex],\r\n      ...updates,\r\n      updatedAt: new Date().toISOString()\r\n    };\r\n    \r\n    return mockStorage.documents[docIndex];\r\n  }\r\n  \r\n  throw new Error('Document not found');\r\n};\r\n\r\n/**\r\n * Get all documents (Admin only)\r\n * @returns {Promise<Array>} - List of all documents\r\n */\r\nexport const getAllDocuments = async () => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 500));\r\n  \r\n  return [...mockStorage.documents].sort((a, b) => \r\n    new Date(b.uploadedAt) - new Date(a.uploadedAt)\r\n  );\r\n};\r\n\r\n/**\r\n * Get a document by ID\r\n * @param {string} documentId - Document ID\r\n * @returns {Promise<Object>} - Document object\r\n */\r\nexport const getDocumentById = async (documentId) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 500));\r\n  \r\n  const document = mockStorage.documents.find(doc => doc.id === documentId);\r\n  \r\n  if (!document) {\r\n    throw new Error('Document not found');\r\n  }\r\n  \r\n  return document;\r\n};\r\n\r\n/**\r\n * Bookmark a document\r\n * @param {string} userId - User ID\r\n * @param {string} documentId - Document ID\r\n * @returns {Promise<Object>} - Bookmark object\r\n */\r\nexport const bookmarkDocument = async (userId, documentId) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 500));\r\n  \r\n  // Check if already bookmarked\r\n  const existingBookmark = mockStorage.bookmarks.find(\r\n    b => b.userId === userId && b.documentId === documentId\r\n  );\r\n  \r\n  if (existingBookmark) {\r\n    return existingBookmark;\r\n  }\r\n  \r\n  // Create new bookmark\r\n  const bookmark = {\r\n    id: `bookmark-${uuidv4()}`,\r\n    userId,\r\n    documentId,\r\n    createdAt: new Date().toISOString()\r\n  };\r\n  \r\n  mockStorage.bookmarks.push(bookmark);\r\n  return bookmark;\r\n};\r\n\r\n/**\r\n * Remove a document bookmark\r\n * @param {string} userId - User ID\r\n * @param {string} documentId - Document ID\r\n * @returns {Promise<boolean>} - Success status\r\n */\r\nexport const removeBookmark = async (userId, documentId) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 500));\r\n  \r\n  const bookmarkIndex = mockStorage.bookmarks.findIndex(\r\n    b => b.userId === userId && b.documentId === documentId\r\n  );\r\n  \r\n  if (bookmarkIndex !== -1) {\r\n    mockStorage.bookmarks.splice(bookmarkIndex, 1);\r\n    return true;\r\n  }\r\n  \r\n  return false;\r\n};\r\n\r\n/**\r\n * Get bookmarked documents for a user\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Array>} - List of bookmarked documents\r\n */\r\nexport const getBookmarkedDocuments = async (userId) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 500));\r\n  \r\n  // Get bookmark entries for this user\r\n  const bookmarks = mockStorage.bookmarks.filter(b => b.userId === userId);\r\n  \r\n  // Get the actual documents\r\n  const bookmarkedDocs = bookmarks.map(bookmark => {\r\n    const doc = mockStorage.documents.find(d => d.id === bookmark.documentId);\r\n    return doc ? { ...doc, bookmarkedAt: bookmark.createdAt } : null;\r\n  }).filter(doc => doc !== null);\r\n  \r\n  return bookmarkedDocs;\r\n};\r\n\r\n/**\r\n * Check if a document is bookmarked\r\n * @param {string} userId - User ID\r\n * @param {string} documentId - Document ID\r\n * @returns {Promise<boolean>} - Whether the document is bookmarked\r\n */\r\nexport const isDocumentBookmarked = async (userId, documentId) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 300));\r\n  \r\n  return mockStorage.bookmarks.some(\r\n    b => b.userId === userId && b.documentId === documentId\r\n  );\r\n};\r\n\r\n/**\r\n * Get all available tags\r\n * @returns {Promise<Array>} - List of all tags\r\n */\r\nexport const getAllTags = async () => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 300));\r\n  return [...mockStorage.tags];\r\n};\r\n\r\n/**\r\n * Create a new tag\r\n * @param {string} name - Tag name\r\n * @param {string} color - Tag color (hex)\r\n * @returns {Promise<Object>} - Created tag\r\n */\r\nexport const createTag = async (name, color = '#2196f3') => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 400));\r\n  \r\n  // Check if tag with this name already exists\r\n  if (mockStorage.tags.some(tag => tag.name.toLowerCase() === name.toLowerCase())) {\r\n    throw new Error(`Tag \"${name}\" already exists`);\r\n  }\r\n  \r\n  const newTag = {\r\n    id: `tag-${uuidv4()}`,\r\n    name,\r\n    color,\r\n    createdAt: new Date().toISOString()\r\n  };\r\n  \r\n  mockStorage.tags.push(newTag);\r\n  return newTag;\r\n};\r\n\r\n/**\r\n * Add tags to a document\r\n * @param {string} documentId - Document ID\r\n * @param {Array<string>} tagIds - Array of tag IDs\r\n * @returns {Promise<Array>} - Updated document tags\r\n */\r\nexport const addTagsToDocument = async (documentId, tagIds) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 400));\r\n  \r\n  // Check if document exists\r\n  const documentExists = mockStorage.documents.some(doc => doc.id === documentId);\r\n  if (!documentExists) {\r\n    throw new Error('Document not found');\r\n  }\r\n  \r\n  // Validate tag IDs\r\n  const validTagIds = tagIds.filter(tagId => \r\n    mockStorage.tags.some(tag => tag.id === tagId)\r\n  );\r\n  \r\n  // Add tags that don't already exist for this document\r\n  validTagIds.forEach(tagId => {\r\n    const existingRelation = mockStorage.documentTags.find(\r\n      dt => dt.documentId === documentId && dt.tagId === tagId\r\n    );\r\n    \r\n    if (!existingRelation) {\r\n      mockStorage.documentTags.push({\r\n        id: `doc-tag-${uuidv4()}`,\r\n        documentId,\r\n        tagId,\r\n        addedAt: new Date().toISOString()\r\n      });\r\n    }\r\n  });\r\n  \r\n  // Return all tags for this document\r\n  return getDocumentTags(documentId);\r\n};\r\n\r\n/**\r\n * Remove a tag from a document\r\n * @param {string} documentId - Document ID\r\n * @param {string} tagId - Tag ID to remove\r\n * @returns {Promise<boolean>} - Success status\r\n */\r\nexport const removeTagFromDocument = async (documentId, tagId) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 300));\r\n  \r\n  const initialLength = mockStorage.documentTags.length;\r\n  \r\n  mockStorage.documentTags = mockStorage.documentTags.filter(\r\n    dt => !(dt.documentId === documentId && dt.tagId === tagId)\r\n  );\r\n  \r\n  return mockStorage.documentTags.length < initialLength;\r\n};\r\n\r\n/**\r\n * Get all tags for a document\r\n * @param {string} documentId - Document ID\r\n * @returns {Promise<Array>} - List of tags\r\n */\r\nexport const getDocumentTags = async (documentId) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 300));\r\n  \r\n  // Get tag IDs for this document\r\n  const tagIds = mockStorage.documentTags\r\n    .filter(dt => dt.documentId === documentId)\r\n    .map(dt => dt.tagId);\r\n  \r\n  // Get full tag objects\r\n  return mockStorage.tags.filter(tag => tagIds.includes(tag.id));\r\n};\r\n\r\n/**\r\n * Get all documents with a specific tag\r\n * @param {string} tagId - Tag ID\r\n * @returns {Promise<Array>} - List of documents\r\n */\r\nexport const getDocumentsByTag = async (tagId) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 500));\r\n  \r\n  // Get document IDs with this tag\r\n  const documentIds = mockStorage.documentTags\r\n    .filter(dt => dt.tagId === tagId)\r\n    .map(dt => dt.documentId);\r\n  \r\n  // Get full document objects\r\n  return mockStorage.documents.filter(doc => documentIds.includes(doc.id));\r\n};\r\n\r\n// Generate some initial sample data\r\nconst generateSampleData = () => {\r\n  const sampleDocs = [\r\n    {\r\n      title: \"Company Annual Report 2023\",\r\n      fileType: \"pdf\",\r\n      description: \"Financial statements and overview of company performance for 2023.\",\r\n      fileSize: 2.4 * 1024 * 1024\r\n    },\r\n    {\r\n      title: \"Project Proposal: AI Integration\",\r\n      fileType: \"docx\",\r\n      description: \"Detailed proposal for integrating AI into our customer service workflows.\",\r\n      fileSize: 1.8 * 1024 * 1024\r\n    },\r\n    {\r\n      title: \"Meeting Notes - Product Team\",\r\n      fileType: \"txt\",\r\n      description: \"Notes from the weekly product team meeting discussing roadmap.\",\r\n      fileSize: 0.2 * 1024 * 1024\r\n    },\r\n    {\r\n      title: \"Technical Documentation\",\r\n      fileType: \"pdf\",\r\n      description: \"API reference and implementation guide for developers.\",\r\n      fileSize: 3.5 * 1024 * 1024\r\n    },\r\n    {\r\n      title: \"Marketing Strategy 2024\",\r\n      fileType: \"docx\",\r\n      description: \"Comprehensive marketing plan and strategy for the upcoming year.\",\r\n      fileSize: 1.2 * 1024 * 1024\r\n    }\r\n  ];\r\n\r\n  // Add sample documents\r\n  sampleDocs.forEach((doc, index) => {\r\n    const docId = `sample-doc-${index + 1}`;\r\n    mockStorage.documents.push({\r\n      id: docId,\r\n      title: doc.title,\r\n      fileName: `${doc.title.toLowerCase().replace(/\\s+/g, '-')}.${doc.fileType}`,\r\n      fileSize: doc.fileSize,\r\n      fileType: doc.fileType,\r\n      fileUrl: `https://example.com/documents/${docId}`,\r\n      uploadedBy: 'user-123',\r\n      uploadedAt: new Date(Date.now() - (index * 86400000)).toISOString(), // Each doc one day apart\r\n      path: `documents/user-123/${docId}.${doc.fileType}`,\r\n      description: doc.description\r\n    });\r\n  });\r\n\r\n  // Add some bookmarks\r\n  mockStorage.bookmarks.push({\r\n    id: 'bookmark-1',\r\n    userId: 'user-123',\r\n    documentId: 'sample-doc-1',\r\n    createdAt: new Date().toISOString()\r\n  });\r\n  \r\n  mockStorage.bookmarks.push({\r\n    id: 'bookmark-2',\r\n    userId: 'user-123',\r\n    documentId: 'sample-doc-3',\r\n    createdAt: new Date().toISOString()\r\n  });\r\n\r\n  // Add sample document tags\r\n  mockStorage.documentTags.push(\r\n    { id: 'doc-tag-1', documentId: 'sample-doc-1', tagId: 'tag-1', addedAt: new Date().toISOString() },\r\n    { id: 'doc-tag-2', documentId: 'sample-doc-1', tagId: 'tag-5', addedAt: new Date().toISOString() },\r\n    { id: 'doc-tag-3', documentId: 'sample-doc-2', tagId: 'tag-2', addedAt: new Date().toISOString() },\r\n    { id: 'doc-tag-4', documentId: 'sample-doc-3', tagId: 'tag-3', addedAt: new Date().toISOString() },\r\n    { id: 'doc-tag-5', documentId: 'sample-doc-4', tagId: 'tag-2', addedAt: new Date().toISOString() }\r\n  );\r\n};\r\n\r\n// Initialize sample data\r\ngenerateSampleData();\r\n\r\nexport default {\r\n  uploadDocument,\r\n  getUserDocuments,\r\n  getDocumentById,\r\n  deleteDocument,\r\n  updateDocumentMetadata,\r\n  getAllDocuments,\r\n  bookmarkDocument,\r\n  removeBookmark,\r\n  getBookmarkedDocuments,\r\n  isDocumentBookmarked,\r\n  getAllTags,\r\n  createTag,\r\n  addTagsToDocument,\r\n  removeTagFromDocument,\r\n  getDocumentTags,\r\n  getDocumentsByTag\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}