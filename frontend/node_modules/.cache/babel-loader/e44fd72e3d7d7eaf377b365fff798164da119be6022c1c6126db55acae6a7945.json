{"ast":null,"code":"// Mock API service for document search and related operations\nimport { getAllDocuments, getUserDocuments, getDocumentById, deleteDocument as storageDeleteDocument } from './storageService';\n\n// Mock processing delay\nconst simulateProcessingDelay = async (minMs = 500, maxMs = 1500) => {\n  const delay = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;\n  await new Promise(resolve => setTimeout(resolve, delay));\n};\n\n// Re-export deleteDocument function from storageService\nexport const deleteDocument = async documentId => {\n  await simulateProcessingDelay(800, 1500);\n  return storageDeleteDocument(documentId);\n};\n\n/**\r\n * Get documents for admin\r\n * @returns {Promise<Array>} - List of all documents with user info\r\n */\nexport const getAdminDocuments = async () => {\n  await simulateProcessingDelay(800, 1500);\n\n  // Get all documents\n  const documents = await getAllDocuments();\n\n  // Enhance with mock user information\n  return documents.map(doc => ({\n    ...doc,\n    userName: doc.uploadedBy === 'user-123' ? 'Demo User' : 'Unknown User',\n    userEmail: doc.uploadedBy === 'user-123' ? 'demo@example.com' : 'unknown@example.com'\n  }));\n};\n\n/**\r\n * Get system stats for admin dashboard\r\n * @returns {Promise<Object>} - System statistics\r\n */\nexport const getStats = async () => {\n  var _documents$, _documents$2;\n  await simulateProcessingDelay(500, 1200);\n  const documents = await getAllDocuments();\n  return {\n    totalDocuments: documents.length,\n    totalUsers: 1,\n    // Mock single user for demo\n    totalStorage: documents.reduce((total, doc) => total + (doc.fileSize || 0), 0) / (1024 * 1024),\n    // in MB\n    documentTypes: {\n      pdf: documents.filter(doc => doc.fileType === 'pdf').length,\n      docx: documents.filter(doc => doc.fileType === 'docx').length,\n      txt: documents.filter(doc => doc.fileType === 'txt').length,\n      other: documents.filter(doc => !['pdf', 'docx', 'txt'].includes(doc.fileType)).length\n    },\n    recentActivity: [{\n      type: 'upload',\n      userId: 'user-123',\n      documentId: (_documents$ = documents[0]) === null || _documents$ === void 0 ? void 0 : _documents$.id,\n      timestamp: new Date().toISOString()\n    }, {\n      type: 'search',\n      userId: 'user-123',\n      query: 'project proposal',\n      timestamp: new Date(Date.now() - 3600000).toISOString()\n    }, {\n      type: 'download',\n      userId: 'user-123',\n      documentId: (_documents$2 = documents[1]) === null || _documents$2 === void 0 ? void 0 : _documents$2.id,\n      timestamp: new Date(Date.now() - 7200000).toISOString()\n    }]\n  };\n};\n\n/**\r\n * Search documents based on query\r\n * @param {string} query - The search query\r\n * @param {Object} options - Search options \r\n * @returns {Promise<Array>} - List of matching documents with relevance scores\r\n */\nexport const searchDocuments = async (query, options = {}) => {\n  const {\n    userId,\n    limit = 10,\n    filters = {}\n  } = options;\n  await simulateProcessingDelay(800, 2000); // Simulate search processing\n\n  // Get documents (all or user-specific)\n  const documents = userId ? await getUserDocuments(userId) : await getAllDocuments();\n  if (!query || !query.trim()) {\n    return documents.slice(0, limit);\n  }\n\n  // Simple search algorithm: check if query appears in title or description\n  // In a real app, this would use vector embeddings and semantic search\n  const results = documents.map(doc => {\n    // Calculate a mock similarity score\n    const titleMatch = (doc.title || '').toLowerCase().includes(query.toLowerCase());\n    const descMatch = (doc.description || '').toLowerCase().includes(query.toLowerCase());\n    let similarityScore = 0;\n    if (titleMatch) similarityScore += 0.6;\n    if (descMatch) similarityScore += 0.4;\n\n    // Add some randomness for variety\n    similarityScore = Math.min(0.99, similarityScore + Math.random() * 0.3);\n\n    // Create a snippet with highlighted match\n    let snippet = doc.description || '';\n    if (snippet && query.length > 0) {\n      const lowerSnippet = snippet.toLowerCase();\n      const lowerQuery = query.toLowerCase();\n      const matchIndex = lowerSnippet.indexOf(lowerQuery);\n      if (matchIndex >= 0) {\n        // Extract context around the match\n        const start = Math.max(0, matchIndex - 40);\n        const end = Math.min(snippet.length, matchIndex + query.length + 40);\n        snippet = (start > 0 ? '...' : '') + snippet.slice(start, end) + (end < snippet.length ? '...' : '');\n      }\n    }\n    return {\n      document_id: doc.id,\n      title: doc.title,\n      file_type: doc.fileType,\n      similarity_score: similarityScore,\n      snippet: snippet || 'No preview available',\n      uploaded_at: doc.uploadedAt,\n      file_url: doc.fileUrl\n    };\n  }).filter(result => result.similarity_score > 0).sort((a, b) => b.similarity_score - a.similarity_score).slice(0, limit);\n  return results;\n};\n\n/**\r\n * Get a document by ID\r\n * @param {string} documentId - The document ID\r\n * @returns {Promise<Object>} - Document object\r\n */\nexport const getDocument = async documentId => {\n  await simulateProcessingDelay(300, 800);\n  return getDocumentById(documentId);\n};\n\n/**\r\n * Generate a summary of a document\r\n * @param {string} documentId - The document ID\r\n * @param {string} summaryType - Type of summary (general, key_points, detailed)\r\n * @param {number} maxLength - Maximum summary length\r\n * @returns {Promise<Object>} - Summary object\r\n */\nexport const getDocumentSummary = async (documentId, summaryType = 'general', maxLength = 500) => {\n  // Longer processing time for summaries\n  await simulateProcessingDelay(1500, 3000);\n  const document = await getDocumentById(documentId);\n  if (!document) {\n    throw new Error('Document not found');\n  }\n\n  // Generate different mock summaries based on type\n  let summary = '';\n  const title = document.title;\n  const fileType = document.fileType;\n  switch (summaryType) {\n    case 'key_points':\n      summary = `Key points from \"${title}\":\\n\\n` + `• This ${fileType.toUpperCase()} document focuses on important business information.\\n` + `• It contains critical data that can be used for decision making.\\n` + `• The document was uploaded on ${new Date(document.uploadedAt).toLocaleDateString()}.\\n` + `• Several sections discuss strategies and implementation details.\\n` + `• Contains references to related documents and resources.`;\n      break;\n    case 'detailed':\n      summary = `Detailed Summary of \"${title}\"\\n\\n` + `This ${fileType.toUpperCase()} document (${(document.fileSize / (1024 * 1024)).toFixed(2)} MB) provides comprehensive information about the subject matter. ` + `The document begins with an introduction to the topic, followed by several sections that delve into specific aspects.\\n\\n` + `The first section outlines the background and context, establishing the foundation for understanding the subsequent content. ` + `Following this, the document presents detailed analysis of various factors and considerations relevant to the topic.\\n\\n` + `Notably, the document includes statistical data, charts, and references to external sources that support its claims and findings. ` + `The conclusion summarizes the key takeaways and suggests potential next steps or areas for further exploration.\\n\\n` + `This document would be particularly useful for stakeholders involved in decision-making processes related to the subject matter.`;\n      break;\n    default:\n      // general\n      summary = `Summary of \"${title}\"\\n\\n` + `This ${fileType.toUpperCase()} document provides information about ${title.toLowerCase().includes('report') ? 'reporting and analysis' : 'the specified topic'}. ` + `It contains approximately ${Math.round(document.fileSize / 1000)} KB of data uploaded on ${new Date(document.uploadedAt).toLocaleDateString()}. ` + `The document covers several important aspects related to the subject matter and presents information in a structured format. ` + `It would be beneficial to review the complete document for comprehensive understanding.`;\n  }\n\n  // Limit summary length if needed\n  if (maxLength > 0 && summary.length > maxLength) {\n    summary = summary.substring(0, maxLength) + '...';\n  }\n  return {\n    document_id: documentId,\n    title: document.title,\n    summary_type: summaryType,\n    summary,\n    generated_at: new Date().toISOString()\n  };\n};\n\n/**\r\n * Ask a question about a document (RAG implementation)\r\n * @param {string} documentId - The document ID\r\n * @param {string} question - User question\r\n * @returns {Promise<Object>} - Answer object\r\n */\nexport const askDocumentQuestion = async (documentId, question) => {\n  // Simulate RAG processing time\n  await simulateProcessingDelay(2000, 4000);\n  const document = await getDocumentById(documentId);\n  if (!document) {\n    throw new Error('Document not found');\n  }\n\n  // Mock answers based on question types\n  let answer = '';\n  if (question.toLowerCase().includes('about') || question.toLowerCase().includes('what is')) {\n    answer = `This document titled \"${document.title}\" is a ${document.fileType.toUpperCase()} file that contains information about ${document.title.split(':')[0]}. It was uploaded on ${new Date(document.uploadedAt).toLocaleDateString()} and is approximately ${(document.fileSize / (1024 * 1024)).toFixed(2)} MB in size.`;\n  } else if (question.toLowerCase().includes('when') || question.toLowerCase().includes('date')) {\n    answer = `The document was uploaded on ${new Date(document.uploadedAt).toLocaleDateString()}.`;\n  } else if (question.toLowerCase().includes('who') || question.toLowerCase().includes('author')) {\n    answer = `The document was uploaded by a user with ID ${document.uploadedBy}. No specific author information is available in the metadata.`;\n  } else if (question.toLowerCase().includes('how') || question.toLowerCase().includes('process')) {\n    answer = `The document explains several processes related to ${document.title}. It outlines steps for implementation and provides guidelines for best practices.`;\n  } else {\n    answer = `Based on the document \"${document.title}\", I can tell you that it contains information relevant to your question. The document discusses various aspects related to ${document.title.split(':')[0]} and provides detailed insights on the matter.`;\n  }\n  return {\n    document_id: documentId,\n    question,\n    answer,\n    confidence: 0.85 + Math.random() * 0.1,\n    generated_at: new Date().toISOString()\n  };\n};\n\n/**\r\n * Get related documents\r\n * @param {string} documentId - The document ID to find related docs for\r\n * @param {number} limit - Maximum number of results\r\n * @returns {Promise<Array>} - List of related documents\r\n */\nexport const getRelatedDocuments = async (documentId, limit = 3) => {\n  await simulateProcessingDelay(800, 1500);\n  const document = await getDocumentById(documentId);\n  if (!document) {\n    throw new Error('Document not found');\n  }\n\n  // Get all documents\n  const allDocuments = await getAllDocuments();\n\n  // Filter out the current document\n  const otherDocuments = allDocuments.filter(doc => doc.id !== documentId);\n\n  // Calculate relatedness score (mock implementation)\n  const relatedDocs = otherDocuments.map(doc => {\n    // Simple mock algorithm - match words in titles\n    const words1 = document.title.toLowerCase().split(/\\W+/);\n    const words2 = doc.title.toLowerCase().split(/\\W+/);\n\n    // Count matching words\n    const matchingWords = words1.filter(word => words2.includes(word) && word.length > 3);\n\n    // Calculate score based on matching words and file type\n    let score = matchingWords.length * 0.15;\n\n    // Same file type bonus\n    if (doc.fileType === document.fileType) {\n      score += 0.2;\n    }\n\n    // Add randomness for variety\n    score = Math.min(0.95, score + Math.random() * 0.4);\n    return {\n      ...doc,\n      relatedness_score: score\n    };\n  });\n\n  // Sort by relatedness and limit results\n  return relatedDocs.filter(doc => doc.relatedness_score > 0.3) // Only include somewhat related docs\n  .sort((a, b) => b.relatedness_score - a.relatedness_score).slice(0, limit);\n};\n\n/**\r\n * Get user activity (for dashboard)\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Object>} - User activity data\r\n */\nexport const getUserActivity = async userId => {\n  await simulateProcessingDelay(500, 1000);\n\n  // Mock user activity data\n  return {\n    recent_searches: [{\n      query: \"project proposal\",\n      timestamp: new Date(Date.now() - 1000 * 60 * 60 * 2).toISOString(),\n      results: 4\n    }, {\n      query: \"financial report\",\n      timestamp: new Date(Date.now() - 1000 * 60 * 60 * 24).toISOString(),\n      results: 2\n    }, {\n      query: \"meeting notes\",\n      timestamp: new Date(Date.now() - 1000 * 60 * 60 * 72).toISOString(),\n      results: 5\n    }],\n    recent_uploads: await getUserDocuments(userId).then(docs => docs.sort((a, b) => new Date(b.uploadedAt) - new Date(a.uploadedAt)).slice(0, 5)),\n    stats: {\n      total_documents: (await getUserDocuments(userId)).length,\n      total_searches: 12,\n      total_storage_used: (await getUserDocuments(userId)).reduce((total, doc) => total + (doc.fileSize || 0), 0) / (1024 * 1024),\n      // in MB\n      documents_by_type: {\n        pdf: (await getUserDocuments(userId)).filter(doc => doc.fileType === 'pdf').length,\n        docx: (await getUserDocuments(userId)).filter(doc => doc.fileType === 'docx').length,\n        txt: (await getUserDocuments(userId)).filter(doc => doc.fileType === 'txt').length\n      }\n    }\n  };\n};\nexport default {\n  searchDocuments,\n  getDocument,\n  getDocumentSummary,\n  askDocumentQuestion,\n  getRelatedDocuments,\n  getUserActivity\n};","map":{"version":3,"names":["getAllDocuments","getUserDocuments","getDocumentById","deleteDocument","storageDeleteDocument","simulateProcessingDelay","minMs","maxMs","delay","Math","floor","random","Promise","resolve","setTimeout","documentId","getAdminDocuments","documents","map","doc","userName","uploadedBy","userEmail","getStats","_documents$","_documents$2","totalDocuments","length","totalUsers","totalStorage","reduce","total","fileSize","documentTypes","pdf","filter","fileType","docx","txt","other","includes","recentActivity","type","userId","id","timestamp","Date","toISOString","query","now","searchDocuments","options","limit","filters","trim","slice","results","titleMatch","title","toLowerCase","descMatch","description","similarityScore","min","snippet","lowerSnippet","lowerQuery","matchIndex","indexOf","start","max","end","document_id","file_type","similarity_score","uploaded_at","uploadedAt","file_url","fileUrl","result","sort","a","b","getDocument","getDocumentSummary","summaryType","maxLength","document","Error","summary","toUpperCase","toLocaleDateString","toFixed","round","substring","summary_type","generated_at","askDocumentQuestion","question","answer","split","confidence","getRelatedDocuments","allDocuments","otherDocuments","relatedDocs","words1","words2","matchingWords","word","score","relatedness_score","getUserActivity","recent_searches","recent_uploads","then","docs","stats","total_documents","total_searches","total_storage_used","documents_by_type"],"sources":["E:/FULL STACK/AI Document Search/frontend/src/services/api.js"],"sourcesContent":["// Mock API service for document search and related operations\r\nimport { getAllDocuments, getUserDocuments, getDocumentById, deleteDocument as storageDeleteDocument } from './storageService';\r\n\r\n// Mock processing delay\r\nconst simulateProcessingDelay = async (minMs = 500, maxMs = 1500) => {\r\n  const delay = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;\r\n  await new Promise(resolve => setTimeout(resolve, delay));\r\n};\r\n\r\n// Re-export deleteDocument function from storageService\r\nexport const deleteDocument = async (documentId) => {\r\n  await simulateProcessingDelay(800, 1500);\r\n  return storageDeleteDocument(documentId);\r\n};\r\n\r\n/**\r\n * Get documents for admin\r\n * @returns {Promise<Array>} - List of all documents with user info\r\n */\r\nexport const getAdminDocuments = async () => {\r\n  await simulateProcessingDelay(800, 1500);\r\n  \r\n  // Get all documents\r\n  const documents = await getAllDocuments();\r\n  \r\n  // Enhance with mock user information\r\n  return documents.map(doc => ({\r\n    ...doc,\r\n    userName: doc.uploadedBy === 'user-123' ? 'Demo User' : 'Unknown User',\r\n    userEmail: doc.uploadedBy === 'user-123' ? 'demo@example.com' : 'unknown@example.com'\r\n  }));\r\n};\r\n\r\n/**\r\n * Get system stats for admin dashboard\r\n * @returns {Promise<Object>} - System statistics\r\n */\r\nexport const getStats = async () => {\r\n  await simulateProcessingDelay(500, 1200);\r\n  \r\n  const documents = await getAllDocuments();\r\n  \r\n  return {\r\n    totalDocuments: documents.length,\r\n    totalUsers: 1, // Mock single user for demo\r\n    totalStorage: documents.reduce((total, doc) => total + (doc.fileSize || 0), 0) / (1024 * 1024), // in MB\r\n    documentTypes: {\r\n      pdf: documents.filter(doc => doc.fileType === 'pdf').length,\r\n      docx: documents.filter(doc => doc.fileType === 'docx').length,\r\n      txt: documents.filter(doc => doc.fileType === 'txt').length,\r\n      other: documents.filter(doc => !['pdf', 'docx', 'txt'].includes(doc.fileType)).length\r\n    },\r\n    recentActivity: [\r\n      { type: 'upload', userId: 'user-123', documentId: documents[0]?.id, timestamp: new Date().toISOString() },\r\n      { type: 'search', userId: 'user-123', query: 'project proposal', timestamp: new Date(Date.now() - 3600000).toISOString() },\r\n      { type: 'download', userId: 'user-123', documentId: documents[1]?.id, timestamp: new Date(Date.now() - 7200000).toISOString() }\r\n    ]\r\n  };\r\n};\r\n\r\n/**\r\n * Search documents based on query\r\n * @param {string} query - The search query\r\n * @param {Object} options - Search options \r\n * @returns {Promise<Array>} - List of matching documents with relevance scores\r\n */\r\nexport const searchDocuments = async (query, options = {}) => {\r\n  const { userId, limit = 10, filters = {} } = options;\r\n  \r\n  await simulateProcessingDelay(800, 2000); // Simulate search processing\r\n  \r\n  // Get documents (all or user-specific)\r\n  const documents = userId \r\n    ? await getUserDocuments(userId)\r\n    : await getAllDocuments();\r\n  \r\n  if (!query || !query.trim()) {\r\n    return documents.slice(0, limit);\r\n  }\r\n  \r\n  // Simple search algorithm: check if query appears in title or description\r\n  // In a real app, this would use vector embeddings and semantic search\r\n  const results = documents\r\n    .map(doc => {\r\n      // Calculate a mock similarity score\r\n      const titleMatch = (doc.title || '').toLowerCase().includes(query.toLowerCase());\r\n      const descMatch = (doc.description || '').toLowerCase().includes(query.toLowerCase());\r\n      \r\n      let similarityScore = 0;\r\n      if (titleMatch) similarityScore += 0.6;\r\n      if (descMatch) similarityScore += 0.4;\r\n      \r\n      // Add some randomness for variety\r\n      similarityScore = Math.min(0.99, similarityScore + Math.random() * 0.3);\r\n      \r\n      // Create a snippet with highlighted match\r\n      let snippet = doc.description || '';\r\n      if (snippet && query.length > 0) {\r\n        const lowerSnippet = snippet.toLowerCase();\r\n        const lowerQuery = query.toLowerCase();\r\n        const matchIndex = lowerSnippet.indexOf(lowerQuery);\r\n        \r\n        if (matchIndex >= 0) {\r\n          // Extract context around the match\r\n          const start = Math.max(0, matchIndex - 40);\r\n          const end = Math.min(snippet.length, matchIndex + query.length + 40);\r\n          snippet = (start > 0 ? '...' : '') + \r\n                    snippet.slice(start, end) + \r\n                    (end < snippet.length ? '...' : '');\r\n        }\r\n      }\r\n      \r\n      return {\r\n        document_id: doc.id,\r\n        title: doc.title,\r\n        file_type: doc.fileType,\r\n        similarity_score: similarityScore,\r\n        snippet: snippet || 'No preview available',\r\n        uploaded_at: doc.uploadedAt,\r\n        file_url: doc.fileUrl\r\n      };\r\n    })\r\n    .filter(result => result.similarity_score > 0)\r\n    .sort((a, b) => b.similarity_score - a.similarity_score)\r\n    .slice(0, limit);\r\n  \r\n  return results;\r\n};\r\n\r\n/**\r\n * Get a document by ID\r\n * @param {string} documentId - The document ID\r\n * @returns {Promise<Object>} - Document object\r\n */\r\nexport const getDocument = async (documentId) => {\r\n  await simulateProcessingDelay(300, 800);\r\n  return getDocumentById(documentId);\r\n};\r\n\r\n/**\r\n * Generate a summary of a document\r\n * @param {string} documentId - The document ID\r\n * @param {string} summaryType - Type of summary (general, key_points, detailed)\r\n * @param {number} maxLength - Maximum summary length\r\n * @returns {Promise<Object>} - Summary object\r\n */\r\nexport const getDocumentSummary = async (documentId, summaryType = 'general', maxLength = 500) => {\r\n  // Longer processing time for summaries\r\n  await simulateProcessingDelay(1500, 3000);\r\n  \r\n  const document = await getDocumentById(documentId);\r\n  if (!document) {\r\n    throw new Error('Document not found');\r\n  }\r\n  \r\n  // Generate different mock summaries based on type\r\n  let summary = '';\r\n  const title = document.title;\r\n  const fileType = document.fileType;\r\n  \r\n  switch (summaryType) {\r\n    case 'key_points':\r\n      summary = `Key points from \"${title}\":\\n\\n` +\r\n                `• This ${fileType.toUpperCase()} document focuses on important business information.\\n` +\r\n                `• It contains critical data that can be used for decision making.\\n` +\r\n                `• The document was uploaded on ${new Date(document.uploadedAt).toLocaleDateString()}.\\n` +\r\n                `• Several sections discuss strategies and implementation details.\\n` +\r\n                `• Contains references to related documents and resources.`;\r\n      break;\r\n    \r\n    case 'detailed':\r\n      summary = `Detailed Summary of \"${title}\"\\n\\n` +\r\n                `This ${fileType.toUpperCase()} document (${(document.fileSize / (1024 * 1024)).toFixed(2)} MB) provides comprehensive information about the subject matter. ` +\r\n                `The document begins with an introduction to the topic, followed by several sections that delve into specific aspects.\\n\\n` +\r\n                `The first section outlines the background and context, establishing the foundation for understanding the subsequent content. ` +\r\n                `Following this, the document presents detailed analysis of various factors and considerations relevant to the topic.\\n\\n` +\r\n                `Notably, the document includes statistical data, charts, and references to external sources that support its claims and findings. ` +\r\n                `The conclusion summarizes the key takeaways and suggests potential next steps or areas for further exploration.\\n\\n` +\r\n                `This document would be particularly useful for stakeholders involved in decision-making processes related to the subject matter.`;\r\n      break;\r\n    \r\n    default: // general\r\n      summary = `Summary of \"${title}\"\\n\\n` +\r\n                `This ${fileType.toUpperCase()} document provides information about ${title.toLowerCase().includes('report') ? 'reporting and analysis' : 'the specified topic'}. ` +\r\n                `It contains approximately ${Math.round(document.fileSize / 1000)} KB of data uploaded on ${new Date(document.uploadedAt).toLocaleDateString()}. ` +\r\n                `The document covers several important aspects related to the subject matter and presents information in a structured format. ` +\r\n                `It would be beneficial to review the complete document for comprehensive understanding.`;\r\n  }\r\n  \r\n  // Limit summary length if needed\r\n  if (maxLength > 0 && summary.length > maxLength) {\r\n    summary = summary.substring(0, maxLength) + '...';\r\n  }\r\n  \r\n  return {\r\n    document_id: documentId,\r\n    title: document.title,\r\n    summary_type: summaryType,\r\n    summary,\r\n    generated_at: new Date().toISOString()\r\n  };\r\n};\r\n\r\n/**\r\n * Ask a question about a document (RAG implementation)\r\n * @param {string} documentId - The document ID\r\n * @param {string} question - User question\r\n * @returns {Promise<Object>} - Answer object\r\n */\r\nexport const askDocumentQuestion = async (documentId, question) => {\r\n  // Simulate RAG processing time\r\n  await simulateProcessingDelay(2000, 4000);\r\n  \r\n  const document = await getDocumentById(documentId);\r\n  if (!document) {\r\n    throw new Error('Document not found');\r\n  }\r\n  \r\n  // Mock answers based on question types\r\n  let answer = '';\r\n  \r\n  if (question.toLowerCase().includes('about') || question.toLowerCase().includes('what is')) {\r\n    answer = `This document titled \"${document.title}\" is a ${document.fileType.toUpperCase()} file that contains information about ${document.title.split(':')[0]}. It was uploaded on ${new Date(document.uploadedAt).toLocaleDateString()} and is approximately ${(document.fileSize / (1024 * 1024)).toFixed(2)} MB in size.`;\r\n  } else if (question.toLowerCase().includes('when') || question.toLowerCase().includes('date')) {\r\n    answer = `The document was uploaded on ${new Date(document.uploadedAt).toLocaleDateString()}.`;\r\n  } else if (question.toLowerCase().includes('who') || question.toLowerCase().includes('author')) {\r\n    answer = `The document was uploaded by a user with ID ${document.uploadedBy}. No specific author information is available in the metadata.`;\r\n  } else if (question.toLowerCase().includes('how') || question.toLowerCase().includes('process')) {\r\n    answer = `The document explains several processes related to ${document.title}. It outlines steps for implementation and provides guidelines for best practices.`;\r\n  } else {\r\n    answer = `Based on the document \"${document.title}\", I can tell you that it contains information relevant to your question. The document discusses various aspects related to ${document.title.split(':')[0]} and provides detailed insights on the matter.`;\r\n  }\r\n  \r\n  return {\r\n    document_id: documentId,\r\n    question,\r\n    answer,\r\n    confidence: 0.85 + (Math.random() * 0.1),\r\n    generated_at: new Date().toISOString()\r\n  };\r\n};\r\n\r\n/**\r\n * Get related documents\r\n * @param {string} documentId - The document ID to find related docs for\r\n * @param {number} limit - Maximum number of results\r\n * @returns {Promise<Array>} - List of related documents\r\n */\r\nexport const getRelatedDocuments = async (documentId, limit = 3) => {\r\n  await simulateProcessingDelay(800, 1500);\r\n  \r\n  const document = await getDocumentById(documentId);\r\n  if (!document) {\r\n    throw new Error('Document not found');\r\n  }\r\n  \r\n  // Get all documents\r\n  const allDocuments = await getAllDocuments();\r\n  \r\n  // Filter out the current document\r\n  const otherDocuments = allDocuments.filter(doc => doc.id !== documentId);\r\n  \r\n  // Calculate relatedness score (mock implementation)\r\n  const relatedDocs = otherDocuments.map(doc => {\r\n    // Simple mock algorithm - match words in titles\r\n    const words1 = document.title.toLowerCase().split(/\\W+/);\r\n    const words2 = doc.title.toLowerCase().split(/\\W+/);\r\n    \r\n    // Count matching words\r\n    const matchingWords = words1.filter(word => words2.includes(word) && word.length > 3);\r\n    \r\n    // Calculate score based on matching words and file type\r\n    let score = matchingWords.length * 0.15;\r\n    \r\n    // Same file type bonus\r\n    if (doc.fileType === document.fileType) {\r\n      score += 0.2;\r\n    }\r\n    \r\n    // Add randomness for variety\r\n    score = Math.min(0.95, score + Math.random() * 0.4);\r\n    \r\n    return {\r\n      ...doc,\r\n      relatedness_score: score\r\n    };\r\n  });\r\n  \r\n  // Sort by relatedness and limit results\r\n  return relatedDocs\r\n    .filter(doc => doc.relatedness_score > 0.3) // Only include somewhat related docs\r\n    .sort((a, b) => b.relatedness_score - a.relatedness_score)\r\n    .slice(0, limit);\r\n};\r\n\r\n/**\r\n * Get user activity (for dashboard)\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Object>} - User activity data\r\n */\r\nexport const getUserActivity = async (userId) => {\r\n  await simulateProcessingDelay(500, 1000);\r\n  \r\n  // Mock user activity data\r\n  return {\r\n    recent_searches: [\r\n      { query: \"project proposal\", timestamp: new Date(Date.now() - 1000 * 60 * 60 * 2).toISOString(), results: 4 },\r\n      { query: \"financial report\", timestamp: new Date(Date.now() - 1000 * 60 * 60 * 24).toISOString(), results: 2 },\r\n      { query: \"meeting notes\", timestamp: new Date(Date.now() - 1000 * 60 * 60 * 72).toISOString(), results: 5 }\r\n    ],\r\n    recent_uploads: await getUserDocuments(userId).then(docs => \r\n      docs.sort((a, b) => new Date(b.uploadedAt) - new Date(a.uploadedAt)).slice(0, 5)\r\n    ),\r\n    stats: {\r\n      total_documents: (await getUserDocuments(userId)).length,\r\n      total_searches: 12,\r\n      total_storage_used: (await getUserDocuments(userId))\r\n        .reduce((total, doc) => total + (doc.fileSize || 0), 0) / (1024 * 1024), // in MB\r\n      documents_by_type: {\r\n        pdf: (await getUserDocuments(userId)).filter(doc => doc.fileType === 'pdf').length,\r\n        docx: (await getUserDocuments(userId)).filter(doc => doc.fileType === 'docx').length,\r\n        txt: (await getUserDocuments(userId)).filter(doc => doc.fileType === 'txt').length\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\nexport default {\r\n  searchDocuments,\r\n  getDocument,\r\n  getDocumentSummary,\r\n  askDocumentQuestion,\r\n  getRelatedDocuments,\r\n  getUserActivity\r\n}; "],"mappings":"AAAA;AACA,SAASA,eAAe,EAAEC,gBAAgB,EAAEC,eAAe,EAAEC,cAAc,IAAIC,qBAAqB,QAAQ,kBAAkB;;AAE9H;AACA,MAAMC,uBAAuB,GAAG,MAAAA,CAAOC,KAAK,GAAG,GAAG,EAAEC,KAAK,GAAG,IAAI,KAAK;EACnE,MAAMC,KAAK,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,IAAIJ,KAAK,GAAGD,KAAK,GAAG,CAAC,CAAC,CAAC,GAAGA,KAAK;EACrE,MAAM,IAAIM,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEL,KAAK,CAAC,CAAC;AAC1D,CAAC;;AAED;AACA,OAAO,MAAML,cAAc,GAAG,MAAOY,UAAU,IAAK;EAClD,MAAMV,uBAAuB,CAAC,GAAG,EAAE,IAAI,CAAC;EACxC,OAAOD,qBAAqB,CAACW,UAAU,CAAC;AAC1C,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMC,iBAAiB,GAAG,MAAAA,CAAA,KAAY;EAC3C,MAAMX,uBAAuB,CAAC,GAAG,EAAE,IAAI,CAAC;;EAExC;EACA,MAAMY,SAAS,GAAG,MAAMjB,eAAe,CAAC,CAAC;;EAEzC;EACA,OAAOiB,SAAS,CAACC,GAAG,CAACC,GAAG,KAAK;IAC3B,GAAGA,GAAG;IACNC,QAAQ,EAAED,GAAG,CAACE,UAAU,KAAK,UAAU,GAAG,WAAW,GAAG,cAAc;IACtEC,SAAS,EAAEH,GAAG,CAACE,UAAU,KAAK,UAAU,GAAG,kBAAkB,GAAG;EAClE,CAAC,CAAC,CAAC;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAME,QAAQ,GAAG,MAAAA,CAAA,KAAY;EAAA,IAAAC,WAAA,EAAAC,YAAA;EAClC,MAAMpB,uBAAuB,CAAC,GAAG,EAAE,IAAI,CAAC;EAExC,MAAMY,SAAS,GAAG,MAAMjB,eAAe,CAAC,CAAC;EAEzC,OAAO;IACL0B,cAAc,EAAET,SAAS,CAACU,MAAM;IAChCC,UAAU,EAAE,CAAC;IAAE;IACfC,YAAY,EAAEZ,SAAS,CAACa,MAAM,CAAC,CAACC,KAAK,EAAEZ,GAAG,KAAKY,KAAK,IAAIZ,GAAG,CAACa,QAAQ,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,GAAG,IAAI,CAAC;IAAE;IAChGC,aAAa,EAAE;MACbC,GAAG,EAAEjB,SAAS,CAACkB,MAAM,CAAChB,GAAG,IAAIA,GAAG,CAACiB,QAAQ,KAAK,KAAK,CAAC,CAACT,MAAM;MAC3DU,IAAI,EAAEpB,SAAS,CAACkB,MAAM,CAAChB,GAAG,IAAIA,GAAG,CAACiB,QAAQ,KAAK,MAAM,CAAC,CAACT,MAAM;MAC7DW,GAAG,EAAErB,SAAS,CAACkB,MAAM,CAAChB,GAAG,IAAIA,GAAG,CAACiB,QAAQ,KAAK,KAAK,CAAC,CAACT,MAAM;MAC3DY,KAAK,EAAEtB,SAAS,CAACkB,MAAM,CAAChB,GAAG,IAAI,CAAC,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,CAAC,CAACqB,QAAQ,CAACrB,GAAG,CAACiB,QAAQ,CAAC,CAAC,CAACT;IACjF,CAAC;IACDc,cAAc,EAAE,CACd;MAAEC,IAAI,EAAE,QAAQ;MAAEC,MAAM,EAAE,UAAU;MAAE5B,UAAU,GAAAS,WAAA,GAAEP,SAAS,CAAC,CAAC,CAAC,cAAAO,WAAA,uBAAZA,WAAA,CAAcoB,EAAE;MAAEC,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;IAAE,CAAC,EACzG;MAAEL,IAAI,EAAE,QAAQ;MAAEC,MAAM,EAAE,UAAU;MAAEK,KAAK,EAAE,kBAAkB;MAAEH,SAAS,EAAE,IAAIC,IAAI,CAACA,IAAI,CAACG,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,CAACF,WAAW,CAAC;IAAE,CAAC,EAC1H;MAAEL,IAAI,EAAE,UAAU;MAAEC,MAAM,EAAE,UAAU;MAAE5B,UAAU,GAAAU,YAAA,GAAER,SAAS,CAAC,CAAC,CAAC,cAAAQ,YAAA,uBAAZA,YAAA,CAAcmB,EAAE;MAAEC,SAAS,EAAE,IAAIC,IAAI,CAACA,IAAI,CAACG,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,CAACF,WAAW,CAAC;IAAE,CAAC;EAEnI,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMG,eAAe,GAAG,MAAAA,CAAOF,KAAK,EAAEG,OAAO,GAAG,CAAC,CAAC,KAAK;EAC5D,MAAM;IAAER,MAAM;IAAES,KAAK,GAAG,EAAE;IAAEC,OAAO,GAAG,CAAC;EAAE,CAAC,GAAGF,OAAO;EAEpD,MAAM9C,uBAAuB,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC;;EAE1C;EACA,MAAMY,SAAS,GAAG0B,MAAM,GACpB,MAAM1C,gBAAgB,CAAC0C,MAAM,CAAC,GAC9B,MAAM3C,eAAe,CAAC,CAAC;EAE3B,IAAI,CAACgD,KAAK,IAAI,CAACA,KAAK,CAACM,IAAI,CAAC,CAAC,EAAE;IAC3B,OAAOrC,SAAS,CAACsC,KAAK,CAAC,CAAC,EAAEH,KAAK,CAAC;EAClC;;EAEA;EACA;EACA,MAAMI,OAAO,GAAGvC,SAAS,CACtBC,GAAG,CAACC,GAAG,IAAI;IACV;IACA,MAAMsC,UAAU,GAAG,CAACtC,GAAG,CAACuC,KAAK,IAAI,EAAE,EAAEC,WAAW,CAAC,CAAC,CAACnB,QAAQ,CAACQ,KAAK,CAACW,WAAW,CAAC,CAAC,CAAC;IAChF,MAAMC,SAAS,GAAG,CAACzC,GAAG,CAAC0C,WAAW,IAAI,EAAE,EAAEF,WAAW,CAAC,CAAC,CAACnB,QAAQ,CAACQ,KAAK,CAACW,WAAW,CAAC,CAAC,CAAC;IAErF,IAAIG,eAAe,GAAG,CAAC;IACvB,IAAIL,UAAU,EAAEK,eAAe,IAAI,GAAG;IACtC,IAAIF,SAAS,EAAEE,eAAe,IAAI,GAAG;;IAErC;IACAA,eAAe,GAAGrD,IAAI,CAACsD,GAAG,CAAC,IAAI,EAAED,eAAe,GAAGrD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC;;IAEvE;IACA,IAAIqD,OAAO,GAAG7C,GAAG,CAAC0C,WAAW,IAAI,EAAE;IACnC,IAAIG,OAAO,IAAIhB,KAAK,CAACrB,MAAM,GAAG,CAAC,EAAE;MAC/B,MAAMsC,YAAY,GAAGD,OAAO,CAACL,WAAW,CAAC,CAAC;MAC1C,MAAMO,UAAU,GAAGlB,KAAK,CAACW,WAAW,CAAC,CAAC;MACtC,MAAMQ,UAAU,GAAGF,YAAY,CAACG,OAAO,CAACF,UAAU,CAAC;MAEnD,IAAIC,UAAU,IAAI,CAAC,EAAE;QACnB;QACA,MAAME,KAAK,GAAG5D,IAAI,CAAC6D,GAAG,CAAC,CAAC,EAAEH,UAAU,GAAG,EAAE,CAAC;QAC1C,MAAMI,GAAG,GAAG9D,IAAI,CAACsD,GAAG,CAACC,OAAO,CAACrC,MAAM,EAAEwC,UAAU,GAAGnB,KAAK,CAACrB,MAAM,GAAG,EAAE,CAAC;QACpEqC,OAAO,GAAG,CAACK,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,EAAE,IACvBL,OAAO,CAACT,KAAK,CAACc,KAAK,EAAEE,GAAG,CAAC,IACxBA,GAAG,GAAGP,OAAO,CAACrC,MAAM,GAAG,KAAK,GAAG,EAAE,CAAC;MAC/C;IACF;IAEA,OAAO;MACL6C,WAAW,EAAErD,GAAG,CAACyB,EAAE;MACnBc,KAAK,EAAEvC,GAAG,CAACuC,KAAK;MAChBe,SAAS,EAAEtD,GAAG,CAACiB,QAAQ;MACvBsC,gBAAgB,EAAEZ,eAAe;MACjCE,OAAO,EAAEA,OAAO,IAAI,sBAAsB;MAC1CW,WAAW,EAAExD,GAAG,CAACyD,UAAU;MAC3BC,QAAQ,EAAE1D,GAAG,CAAC2D;IAChB,CAAC;EACH,CAAC,CAAC,CACD3C,MAAM,CAAC4C,MAAM,IAAIA,MAAM,CAACL,gBAAgB,GAAG,CAAC,CAAC,CAC7CM,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACR,gBAAgB,GAAGO,CAAC,CAACP,gBAAgB,CAAC,CACvDnB,KAAK,CAAC,CAAC,EAAEH,KAAK,CAAC;EAElB,OAAOI,OAAO;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAM2B,WAAW,GAAG,MAAOpE,UAAU,IAAK;EAC/C,MAAMV,uBAAuB,CAAC,GAAG,EAAE,GAAG,CAAC;EACvC,OAAOH,eAAe,CAACa,UAAU,CAAC;AACpC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMqE,kBAAkB,GAAG,MAAAA,CAAOrE,UAAU,EAAEsE,WAAW,GAAG,SAAS,EAAEC,SAAS,GAAG,GAAG,KAAK;EAChG;EACA,MAAMjF,uBAAuB,CAAC,IAAI,EAAE,IAAI,CAAC;EAEzC,MAAMkF,QAAQ,GAAG,MAAMrF,eAAe,CAACa,UAAU,CAAC;EAClD,IAAI,CAACwE,QAAQ,EAAE;IACb,MAAM,IAAIC,KAAK,CAAC,oBAAoB,CAAC;EACvC;;EAEA;EACA,IAAIC,OAAO,GAAG,EAAE;EAChB,MAAM/B,KAAK,GAAG6B,QAAQ,CAAC7B,KAAK;EAC5B,MAAMtB,QAAQ,GAAGmD,QAAQ,CAACnD,QAAQ;EAElC,QAAQiD,WAAW;IACjB,KAAK,YAAY;MACfI,OAAO,GAAG,oBAAoB/B,KAAK,QAAQ,GACjC,UAAUtB,QAAQ,CAACsD,WAAW,CAAC,CAAC,wDAAwD,GACxF,qEAAqE,GACrE,kCAAkC,IAAI5C,IAAI,CAACyC,QAAQ,CAACX,UAAU,CAAC,CAACe,kBAAkB,CAAC,CAAC,KAAK,GACzF,qEAAqE,GACrE,2DAA2D;MACrE;IAEF,KAAK,UAAU;MACbF,OAAO,GAAG,wBAAwB/B,KAAK,OAAO,GACpC,QAAQtB,QAAQ,CAACsD,WAAW,CAAC,CAAC,cAAc,CAACH,QAAQ,CAACvD,QAAQ,IAAI,IAAI,GAAG,IAAI,CAAC,EAAE4D,OAAO,CAAC,CAAC,CAAC,oEAAoE,GAC9J,2HAA2H,GAC3H,+HAA+H,GAC/H,0HAA0H,GAC1H,oIAAoI,GACpI,qHAAqH,GACrH,kIAAkI;MAC5I;IAEF;MAAS;MACPH,OAAO,GAAG,eAAe/B,KAAK,OAAO,GAC3B,QAAQtB,QAAQ,CAACsD,WAAW,CAAC,CAAC,wCAAwChC,KAAK,CAACC,WAAW,CAAC,CAAC,CAACnB,QAAQ,CAAC,QAAQ,CAAC,GAAG,wBAAwB,GAAG,qBAAqB,IAAI,GACnK,6BAA6B/B,IAAI,CAACoF,KAAK,CAACN,QAAQ,CAACvD,QAAQ,GAAG,IAAI,CAAC,2BAA2B,IAAIc,IAAI,CAACyC,QAAQ,CAACX,UAAU,CAAC,CAACe,kBAAkB,CAAC,CAAC,IAAI,GAClJ,+HAA+H,GAC/H,yFAAyF;EACvG;;EAEA;EACA,IAAIL,SAAS,GAAG,CAAC,IAAIG,OAAO,CAAC9D,MAAM,GAAG2D,SAAS,EAAE;IAC/CG,OAAO,GAAGA,OAAO,CAACK,SAAS,CAAC,CAAC,EAAER,SAAS,CAAC,GAAG,KAAK;EACnD;EAEA,OAAO;IACLd,WAAW,EAAEzD,UAAU;IACvB2C,KAAK,EAAE6B,QAAQ,CAAC7B,KAAK;IACrBqC,YAAY,EAAEV,WAAW;IACzBI,OAAO;IACPO,YAAY,EAAE,IAAIlD,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;EACvC,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMkD,mBAAmB,GAAG,MAAAA,CAAOlF,UAAU,EAAEmF,QAAQ,KAAK;EACjE;EACA,MAAM7F,uBAAuB,CAAC,IAAI,EAAE,IAAI,CAAC;EAEzC,MAAMkF,QAAQ,GAAG,MAAMrF,eAAe,CAACa,UAAU,CAAC;EAClD,IAAI,CAACwE,QAAQ,EAAE;IACb,MAAM,IAAIC,KAAK,CAAC,oBAAoB,CAAC;EACvC;;EAEA;EACA,IAAIW,MAAM,GAAG,EAAE;EAEf,IAAID,QAAQ,CAACvC,WAAW,CAAC,CAAC,CAACnB,QAAQ,CAAC,OAAO,CAAC,IAAI0D,QAAQ,CAACvC,WAAW,CAAC,CAAC,CAACnB,QAAQ,CAAC,SAAS,CAAC,EAAE;IAC1F2D,MAAM,GAAG,yBAAyBZ,QAAQ,CAAC7B,KAAK,UAAU6B,QAAQ,CAACnD,QAAQ,CAACsD,WAAW,CAAC,CAAC,yCAAyCH,QAAQ,CAAC7B,KAAK,CAAC0C,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,wBAAwB,IAAItD,IAAI,CAACyC,QAAQ,CAACX,UAAU,CAAC,CAACe,kBAAkB,CAAC,CAAC,yBAAyB,CAACJ,QAAQ,CAACvD,QAAQ,IAAI,IAAI,GAAG,IAAI,CAAC,EAAE4D,OAAO,CAAC,CAAC,CAAC,cAAc;EAC/T,CAAC,MAAM,IAAIM,QAAQ,CAACvC,WAAW,CAAC,CAAC,CAACnB,QAAQ,CAAC,MAAM,CAAC,IAAI0D,QAAQ,CAACvC,WAAW,CAAC,CAAC,CAACnB,QAAQ,CAAC,MAAM,CAAC,EAAE;IAC7F2D,MAAM,GAAG,gCAAgC,IAAIrD,IAAI,CAACyC,QAAQ,CAACX,UAAU,CAAC,CAACe,kBAAkB,CAAC,CAAC,GAAG;EAChG,CAAC,MAAM,IAAIO,QAAQ,CAACvC,WAAW,CAAC,CAAC,CAACnB,QAAQ,CAAC,KAAK,CAAC,IAAI0D,QAAQ,CAACvC,WAAW,CAAC,CAAC,CAACnB,QAAQ,CAAC,QAAQ,CAAC,EAAE;IAC9F2D,MAAM,GAAG,+CAA+CZ,QAAQ,CAAClE,UAAU,gEAAgE;EAC7I,CAAC,MAAM,IAAI6E,QAAQ,CAACvC,WAAW,CAAC,CAAC,CAACnB,QAAQ,CAAC,KAAK,CAAC,IAAI0D,QAAQ,CAACvC,WAAW,CAAC,CAAC,CAACnB,QAAQ,CAAC,SAAS,CAAC,EAAE;IAC/F2D,MAAM,GAAG,sDAAsDZ,QAAQ,CAAC7B,KAAK,oFAAoF;EACnK,CAAC,MAAM;IACLyC,MAAM,GAAG,0BAA0BZ,QAAQ,CAAC7B,KAAK,+HAA+H6B,QAAQ,CAAC7B,KAAK,CAAC0C,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,gDAAgD;EAC9P;EAEA,OAAO;IACL5B,WAAW,EAAEzD,UAAU;IACvBmF,QAAQ;IACRC,MAAM;IACNE,UAAU,EAAE,IAAI,GAAI5F,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,GAAI;IACxCqF,YAAY,EAAE,IAAIlD,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;EACvC,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMuD,mBAAmB,GAAG,MAAAA,CAAOvF,UAAU,EAAEqC,KAAK,GAAG,CAAC,KAAK;EAClE,MAAM/C,uBAAuB,CAAC,GAAG,EAAE,IAAI,CAAC;EAExC,MAAMkF,QAAQ,GAAG,MAAMrF,eAAe,CAACa,UAAU,CAAC;EAClD,IAAI,CAACwE,QAAQ,EAAE;IACb,MAAM,IAAIC,KAAK,CAAC,oBAAoB,CAAC;EACvC;;EAEA;EACA,MAAMe,YAAY,GAAG,MAAMvG,eAAe,CAAC,CAAC;;EAE5C;EACA,MAAMwG,cAAc,GAAGD,YAAY,CAACpE,MAAM,CAAChB,GAAG,IAAIA,GAAG,CAACyB,EAAE,KAAK7B,UAAU,CAAC;;EAExE;EACA,MAAM0F,WAAW,GAAGD,cAAc,CAACtF,GAAG,CAACC,GAAG,IAAI;IAC5C;IACA,MAAMuF,MAAM,GAAGnB,QAAQ,CAAC7B,KAAK,CAACC,WAAW,CAAC,CAAC,CAACyC,KAAK,CAAC,KAAK,CAAC;IACxD,MAAMO,MAAM,GAAGxF,GAAG,CAACuC,KAAK,CAACC,WAAW,CAAC,CAAC,CAACyC,KAAK,CAAC,KAAK,CAAC;;IAEnD;IACA,MAAMQ,aAAa,GAAGF,MAAM,CAACvE,MAAM,CAAC0E,IAAI,IAAIF,MAAM,CAACnE,QAAQ,CAACqE,IAAI,CAAC,IAAIA,IAAI,CAAClF,MAAM,GAAG,CAAC,CAAC;;IAErF;IACA,IAAImF,KAAK,GAAGF,aAAa,CAACjF,MAAM,GAAG,IAAI;;IAEvC;IACA,IAAIR,GAAG,CAACiB,QAAQ,KAAKmD,QAAQ,CAACnD,QAAQ,EAAE;MACtC0E,KAAK,IAAI,GAAG;IACd;;IAEA;IACAA,KAAK,GAAGrG,IAAI,CAACsD,GAAG,CAAC,IAAI,EAAE+C,KAAK,GAAGrG,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC;IAEnD,OAAO;MACL,GAAGQ,GAAG;MACN4F,iBAAiB,EAAED;IACrB,CAAC;EACH,CAAC,CAAC;;EAEF;EACA,OAAOL,WAAW,CACftE,MAAM,CAAChB,GAAG,IAAIA,GAAG,CAAC4F,iBAAiB,GAAG,GAAG,CAAC,CAAC;EAAA,CAC3C/B,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAAC6B,iBAAiB,GAAG9B,CAAC,CAAC8B,iBAAiB,CAAC,CACzDxD,KAAK,CAAC,CAAC,EAAEH,KAAK,CAAC;AACpB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAM4D,eAAe,GAAG,MAAOrE,MAAM,IAAK;EAC/C,MAAMtC,uBAAuB,CAAC,GAAG,EAAE,IAAI,CAAC;;EAExC;EACA,OAAO;IACL4G,eAAe,EAAE,CACf;MAAEjE,KAAK,EAAE,kBAAkB;MAAEH,SAAS,EAAE,IAAIC,IAAI,CAACA,IAAI,CAACG,GAAG,CAAC,CAAC,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAACF,WAAW,CAAC,CAAC;MAAES,OAAO,EAAE;IAAE,CAAC,EAC7G;MAAER,KAAK,EAAE,kBAAkB;MAAEH,SAAS,EAAE,IAAIC,IAAI,CAACA,IAAI,CAACG,GAAG,CAAC,CAAC,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAACF,WAAW,CAAC,CAAC;MAAES,OAAO,EAAE;IAAE,CAAC,EAC9G;MAAER,KAAK,EAAE,eAAe;MAAEH,SAAS,EAAE,IAAIC,IAAI,CAACA,IAAI,CAACG,GAAG,CAAC,CAAC,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAACF,WAAW,CAAC,CAAC;MAAES,OAAO,EAAE;IAAE,CAAC,CAC5G;IACD0D,cAAc,EAAE,MAAMjH,gBAAgB,CAAC0C,MAAM,CAAC,CAACwE,IAAI,CAACC,IAAI,IACtDA,IAAI,CAACpC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK,IAAIpC,IAAI,CAACoC,CAAC,CAACN,UAAU,CAAC,GAAG,IAAI9B,IAAI,CAACmC,CAAC,CAACL,UAAU,CAAC,CAAC,CAACrB,KAAK,CAAC,CAAC,EAAE,CAAC,CACjF,CAAC;IACD8D,KAAK,EAAE;MACLC,eAAe,EAAE,CAAC,MAAMrH,gBAAgB,CAAC0C,MAAM,CAAC,EAAEhB,MAAM;MACxD4F,cAAc,EAAE,EAAE;MAClBC,kBAAkB,EAAE,CAAC,MAAMvH,gBAAgB,CAAC0C,MAAM,CAAC,EAChDb,MAAM,CAAC,CAACC,KAAK,EAAEZ,GAAG,KAAKY,KAAK,IAAIZ,GAAG,CAACa,QAAQ,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,GAAG,IAAI,CAAC;MAAE;MAC3EyF,iBAAiB,EAAE;QACjBvF,GAAG,EAAE,CAAC,MAAMjC,gBAAgB,CAAC0C,MAAM,CAAC,EAAER,MAAM,CAAChB,GAAG,IAAIA,GAAG,CAACiB,QAAQ,KAAK,KAAK,CAAC,CAACT,MAAM;QAClFU,IAAI,EAAE,CAAC,MAAMpC,gBAAgB,CAAC0C,MAAM,CAAC,EAAER,MAAM,CAAChB,GAAG,IAAIA,GAAG,CAACiB,QAAQ,KAAK,MAAM,CAAC,CAACT,MAAM;QACpFW,GAAG,EAAE,CAAC,MAAMrC,gBAAgB,CAAC0C,MAAM,CAAC,EAAER,MAAM,CAAChB,GAAG,IAAIA,GAAG,CAACiB,QAAQ,KAAK,KAAK,CAAC,CAACT;MAC9E;IACF;EACF,CAAC;AACH,CAAC;AAED,eAAe;EACbuB,eAAe;EACfiC,WAAW;EACXC,kBAAkB;EAClBa,mBAAmB;EACnBK,mBAAmB;EACnBU;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}