{"ast":null,"code":"import { getStorage, ref, uploadBytesResumable, getDownloadURL, deleteObject, listAll } from 'firebase/storage';\nimport { getFirestore, collection, addDoc, deleteDoc, doc, updateDoc, getDoc, getDocs, query, where, orderBy } from 'firebase/firestore';\nimport { v4 as uuidv4 } from 'uuid';\n\n// Initialize Firebase Storage\nlet storage = null;\nlet firestore = null;\n\n// This would be properly initialized in a real app\ntry {\n  storage = getStorage();\n  firestore = getFirestore();\n} catch (error) {\n  console.error(\"Firebase not initialized:\", error);\n  // For demo purposes, we'll mock Firebase functionality\n}\n\n// Mock storage for testing without Firebase\nconst mockStorage = {\n  documents: [],\n  documentCounter: 0,\n  users: {\n    'user-123': {\n      name: 'Demo User',\n      email: 'demo@example.com'\n    }\n  },\n  bookmarks: []\n};\n\n/**\r\n * Upload a document to storage\r\n * @param {File} file - The file to upload\r\n * @param {string} title - Document title\r\n * @param {string} userId - User ID who is uploading\r\n * @param {Function} progressCallback - Callback for upload progress\r\n * @returns {Promise<Object>} - Uploaded document metadata\r\n */\nexport const uploadDocument = async (file, title, userId, progressCallback = () => {}) => {\n  return new Promise(resolve => {\n    // Simulate upload progress\n    let progress = 0;\n    const progressInterval = setInterval(() => {\n      progress += 10;\n      progressCallback(progress);\n      if (progress >= 100) {\n        clearInterval(progressInterval);\n\n        // Create mock document\n        const fileExtension = file.name.split('.').pop().toLowerCase();\n        const docId = `doc-${uuidv4()}`;\n        const newDoc = {\n          id: docId,\n          title,\n          fileName: file.name,\n          fileSize: file.size,\n          fileType: fileExtension,\n          fileUrl: URL.createObjectURL(file),\n          // Create a blob URL for the file\n          uploadedBy: userId,\n          uploadedAt: new Date().toISOString(),\n          path: `documents/${userId}/${docId}.${fileExtension}`,\n          description: `This is a ${fileExtension.toUpperCase()} document uploaded by the user.`\n        };\n        mockStorage.documents.push(newDoc);\n        resolve(newDoc);\n      }\n    }, 300);\n  });\n};\n\n/**\r\n * Get all documents for a user\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Array>} - List of documents\r\n */\nexport const getUserDocuments = async userId => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 500));\n  return mockStorage.documents.filter(doc => doc.uploadedBy === userId);\n};\n\n/**\r\n * Delete a document\r\n * @param {string} documentId - Document ID to delete\r\n * @returns {Promise<boolean>} - Success status\r\n */\nexport const deleteDocument = async documentId => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 500));\n\n  // Find and remove the document\n  const docIndex = mockStorage.documents.findIndex(doc => doc.id === documentId);\n  if (docIndex !== -1) {\n    mockStorage.documents.splice(docIndex, 1);\n\n    // Also remove from bookmarks\n    mockStorage.bookmarks = mockStorage.bookmarks.filter(bookmark => bookmark.documentId !== documentId);\n    return true;\n  }\n  return false;\n};\n\n/**\r\n * Update document metadata\r\n * @param {string} documentId - Document ID to update\r\n * @param {Object} updates - Fields to update\r\n * @returns {Promise<Object>} - Updated document\r\n */\nexport const updateDocumentMetadata = async (documentId, updates) => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 500));\n  const docIndex = mockStorage.documents.findIndex(doc => doc.id === documentId);\n  if (docIndex !== -1) {\n    // Update the document\n    mockStorage.documents[docIndex] = {\n      ...mockStorage.documents[docIndex],\n      ...updates,\n      updatedAt: new Date().toISOString()\n    };\n    return mockStorage.documents[docIndex];\n  }\n  throw new Error('Document not found');\n};\n\n/**\r\n * Get all documents (Admin only)\r\n * @returns {Promise<Array>} - List of all documents\r\n */\nexport const getAllDocuments = async () => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 500));\n  return [...mockStorage.documents].sort((a, b) => new Date(b.uploadedAt) - new Date(a.uploadedAt));\n};\n\n/**\r\n * Get a document by ID\r\n * @param {string} documentId - Document ID\r\n * @returns {Promise<Object>} - Document object\r\n */\nexport const getDocumentById = async documentId => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 500));\n  const document = mockStorage.documents.find(doc => doc.id === documentId);\n  if (!document) {\n    throw new Error('Document not found');\n  }\n  return document;\n};\n\n/**\r\n * Bookmark a document\r\n * @param {string} userId - User ID\r\n * @param {string} documentId - Document ID\r\n * @returns {Promise<Object>} - Bookmark object\r\n */\nexport const bookmarkDocument = async (userId, documentId) => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 500));\n\n  // Check if already bookmarked\n  const existingBookmark = mockStorage.bookmarks.find(b => b.userId === userId && b.documentId === documentId);\n  if (existingBookmark) {\n    return existingBookmark;\n  }\n\n  // Create new bookmark\n  const bookmark = {\n    id: `bookmark-${uuidv4()}`,\n    userId,\n    documentId,\n    createdAt: new Date().toISOString()\n  };\n  mockStorage.bookmarks.push(bookmark);\n  return bookmark;\n};\n\n/**\r\n * Remove a document bookmark\r\n * @param {string} userId - User ID\r\n * @param {string} documentId - Document ID\r\n * @returns {Promise<boolean>} - Success status\r\n */\nexport const removeBookmark = async (userId, documentId) => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 500));\n  const bookmarkIndex = mockStorage.bookmarks.findIndex(b => b.userId === userId && b.documentId === documentId);\n  if (bookmarkIndex !== -1) {\n    mockStorage.bookmarks.splice(bookmarkIndex, 1);\n    return true;\n  }\n  return false;\n};\n\n/**\r\n * Get bookmarked documents for a user\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Array>} - List of bookmarked documents\r\n */\nexport const getBookmarkedDocuments = async userId => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 500));\n\n  // Get bookmark entries for this user\n  const bookmarks = mockStorage.bookmarks.filter(b => b.userId === userId);\n\n  // Get the actual documents\n  const bookmarkedDocs = bookmarks.map(bookmark => {\n    const doc = mockStorage.documents.find(d => d.id === bookmark.documentId);\n    return doc ? {\n      ...doc,\n      bookmarkedAt: bookmark.createdAt\n    } : null;\n  }).filter(doc => doc !== null);\n  return bookmarkedDocs;\n};\n\n/**\r\n * Check if a document is bookmarked\r\n * @param {string} userId - User ID\r\n * @param {string} documentId - Document ID\r\n * @returns {Promise<boolean>} - Whether the document is bookmarked\r\n */\nexport const isDocumentBookmarked = async (userId, documentId) => {\n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 300));\n  return mockStorage.bookmarks.some(b => b.userId === userId && b.documentId === documentId);\n};\n\n// Generate some initial sample data\nconst generateSampleData = () => {\n  const sampleDocs = [{\n    title: \"Company Annual Report 2023\",\n    fileType: \"pdf\",\n    description: \"Financial statements and overview of company performance for 2023.\",\n    fileSize: 2.4 * 1024 * 1024\n  }, {\n    title: \"Project Proposal: AI Integration\",\n    fileType: \"docx\",\n    description: \"Detailed proposal for integrating AI into our customer service workflows.\",\n    fileSize: 1.8 * 1024 * 1024\n  }, {\n    title: \"Meeting Notes - Product Team\",\n    fileType: \"txt\",\n    description: \"Notes from the weekly product team meeting discussing roadmap.\",\n    fileSize: 0.2 * 1024 * 1024\n  }, {\n    title: \"Technical Documentation\",\n    fileType: \"pdf\",\n    description: \"API reference and implementation guide for developers.\",\n    fileSize: 3.5 * 1024 * 1024\n  }, {\n    title: \"Marketing Strategy 2024\",\n    fileType: \"docx\",\n    description: \"Comprehensive marketing plan and strategy for the upcoming year.\",\n    fileSize: 1.2 * 1024 * 1024\n  }];\n\n  // Add sample documents\n  sampleDocs.forEach((doc, index) => {\n    const docId = `sample-doc-${index + 1}`;\n    mockStorage.documents.push({\n      id: docId,\n      title: doc.title,\n      fileName: `${doc.title.toLowerCase().replace(/\\s+/g, '-')}.${doc.fileType}`,\n      fileSize: doc.fileSize,\n      fileType: doc.fileType,\n      fileUrl: `https://example.com/documents/${docId}`,\n      uploadedBy: 'user-123',\n      uploadedAt: new Date(Date.now() - index * 86400000).toISOString(),\n      // Each doc one day apart\n      path: `documents/user-123/${docId}.${doc.fileType}`,\n      description: doc.description\n    });\n  });\n\n  // Add some bookmarks\n  mockStorage.bookmarks.push({\n    id: 'bookmark-1',\n    userId: 'user-123',\n    documentId: 'sample-doc-1',\n    createdAt: new Date().toISOString()\n  });\n  mockStorage.bookmarks.push({\n    id: 'bookmark-2',\n    userId: 'user-123',\n    documentId: 'sample-doc-3',\n    createdAt: new Date().toISOString()\n  });\n};\n\n// Initialize sample data\ngenerateSampleData();\nexport default {\n  uploadDocument,\n  getUserDocuments,\n  getDocumentById,\n  deleteDocument,\n  updateDocumentMetadata,\n  getAllDocuments,\n  bookmarkDocument,\n  removeBookmark,\n  getBookmarkedDocuments,\n  isDocumentBookmarked\n};","map":{"version":3,"names":["getStorage","ref","uploadBytesResumable","getDownloadURL","deleteObject","listAll","getFirestore","collection","addDoc","deleteDoc","doc","updateDoc","getDoc","getDocs","query","where","orderBy","v4","uuidv4","storage","firestore","error","console","mockStorage","documents","documentCounter","users","name","email","bookmarks","uploadDocument","file","title","userId","progressCallback","Promise","resolve","progress","progressInterval","setInterval","clearInterval","fileExtension","split","pop","toLowerCase","docId","newDoc","id","fileName","fileSize","size","fileType","fileUrl","URL","createObjectURL","uploadedBy","uploadedAt","Date","toISOString","path","description","toUpperCase","push","getUserDocuments","setTimeout","filter","deleteDocument","documentId","docIndex","findIndex","splice","bookmark","updateDocumentMetadata","updates","updatedAt","Error","getAllDocuments","sort","a","b","getDocumentById","document","find","bookmarkDocument","existingBookmark","createdAt","removeBookmark","bookmarkIndex","getBookmarkedDocuments","bookmarkedDocs","map","d","bookmarkedAt","isDocumentBookmarked","some","generateSampleData","sampleDocs","forEach","index","replace","now"],"sources":["E:/FULL STACK/AI Document Search/frontend/src/services/storageService.js"],"sourcesContent":["import { getStorage, ref, uploadBytesResumable, getDownloadURL, deleteObject, listAll } from 'firebase/storage';\r\nimport { getFirestore, collection, addDoc, deleteDoc, doc, updateDoc, getDoc, getDocs, query, where, orderBy } from 'firebase/firestore';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\n// Initialize Firebase Storage\r\nlet storage = null;\r\nlet firestore = null;\r\n\r\n// This would be properly initialized in a real app\r\ntry {\r\n  storage = getStorage();\r\n  firestore = getFirestore();\r\n} catch (error) {\r\n  console.error(\"Firebase not initialized:\", error);\r\n  // For demo purposes, we'll mock Firebase functionality\r\n}\r\n\r\n// Mock storage for testing without Firebase\r\nconst mockStorage = {\r\n  documents: [],\r\n  documentCounter: 0,\r\n  users: {\r\n    'user-123': { name: 'Demo User', email: 'demo@example.com' }\r\n  },\r\n  bookmarks: []\r\n};\r\n\r\n/**\r\n * Upload a document to storage\r\n * @param {File} file - The file to upload\r\n * @param {string} title - Document title\r\n * @param {string} userId - User ID who is uploading\r\n * @param {Function} progressCallback - Callback for upload progress\r\n * @returns {Promise<Object>} - Uploaded document metadata\r\n */\r\nexport const uploadDocument = async (file, title, userId, progressCallback = () => {}) => {\r\n  return new Promise((resolve) => {\r\n    // Simulate upload progress\r\n    let progress = 0;\r\n    const progressInterval = setInterval(() => {\r\n      progress += 10;\r\n      progressCallback(progress);\r\n      \r\n      if (progress >= 100) {\r\n        clearInterval(progressInterval);\r\n        \r\n        // Create mock document\r\n        const fileExtension = file.name.split('.').pop().toLowerCase();\r\n        const docId = `doc-${uuidv4()}`;\r\n        const newDoc = {\r\n          id: docId,\r\n          title,\r\n          fileName: file.name,\r\n          fileSize: file.size,\r\n          fileType: fileExtension,\r\n          fileUrl: URL.createObjectURL(file), // Create a blob URL for the file\r\n          uploadedBy: userId,\r\n          uploadedAt: new Date().toISOString(),\r\n          path: `documents/${userId}/${docId}.${fileExtension}`,\r\n          description: `This is a ${fileExtension.toUpperCase()} document uploaded by the user.`\r\n        };\r\n        \r\n        mockStorage.documents.push(newDoc);\r\n        resolve(newDoc);\r\n      }\r\n    }, 300);\r\n  });\r\n};\r\n\r\n/**\r\n * Get all documents for a user\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Array>} - List of documents\r\n */\r\nexport const getUserDocuments = async (userId) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 500));\r\n  return mockStorage.documents.filter(doc => doc.uploadedBy === userId);\r\n};\r\n\r\n/**\r\n * Delete a document\r\n * @param {string} documentId - Document ID to delete\r\n * @returns {Promise<boolean>} - Success status\r\n */\r\nexport const deleteDocument = async (documentId) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 500));\r\n  \r\n  // Find and remove the document\r\n  const docIndex = mockStorage.documents.findIndex(doc => doc.id === documentId);\r\n  \r\n  if (docIndex !== -1) {\r\n    mockStorage.documents.splice(docIndex, 1);\r\n    \r\n    // Also remove from bookmarks\r\n    mockStorage.bookmarks = mockStorage.bookmarks.filter(\r\n      bookmark => bookmark.documentId !== documentId\r\n    );\r\n    \r\n    return true;\r\n  }\r\n  \r\n  return false;\r\n};\r\n\r\n/**\r\n * Update document metadata\r\n * @param {string} documentId - Document ID to update\r\n * @param {Object} updates - Fields to update\r\n * @returns {Promise<Object>} - Updated document\r\n */\r\nexport const updateDocumentMetadata = async (documentId, updates) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 500));\r\n  \r\n  const docIndex = mockStorage.documents.findIndex(doc => doc.id === documentId);\r\n  \r\n  if (docIndex !== -1) {\r\n    // Update the document\r\n    mockStorage.documents[docIndex] = {\r\n      ...mockStorage.documents[docIndex],\r\n      ...updates,\r\n      updatedAt: new Date().toISOString()\r\n    };\r\n    \r\n    return mockStorage.documents[docIndex];\r\n  }\r\n  \r\n  throw new Error('Document not found');\r\n};\r\n\r\n/**\r\n * Get all documents (Admin only)\r\n * @returns {Promise<Array>} - List of all documents\r\n */\r\nexport const getAllDocuments = async () => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 500));\r\n  \r\n  return [...mockStorage.documents].sort((a, b) => \r\n    new Date(b.uploadedAt) - new Date(a.uploadedAt)\r\n  );\r\n};\r\n\r\n/**\r\n * Get a document by ID\r\n * @param {string} documentId - Document ID\r\n * @returns {Promise<Object>} - Document object\r\n */\r\nexport const getDocumentById = async (documentId) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 500));\r\n  \r\n  const document = mockStorage.documents.find(doc => doc.id === documentId);\r\n  \r\n  if (!document) {\r\n    throw new Error('Document not found');\r\n  }\r\n  \r\n  return document;\r\n};\r\n\r\n/**\r\n * Bookmark a document\r\n * @param {string} userId - User ID\r\n * @param {string} documentId - Document ID\r\n * @returns {Promise<Object>} - Bookmark object\r\n */\r\nexport const bookmarkDocument = async (userId, documentId) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 500));\r\n  \r\n  // Check if already bookmarked\r\n  const existingBookmark = mockStorage.bookmarks.find(\r\n    b => b.userId === userId && b.documentId === documentId\r\n  );\r\n  \r\n  if (existingBookmark) {\r\n    return existingBookmark;\r\n  }\r\n  \r\n  // Create new bookmark\r\n  const bookmark = {\r\n    id: `bookmark-${uuidv4()}`,\r\n    userId,\r\n    documentId,\r\n    createdAt: new Date().toISOString()\r\n  };\r\n  \r\n  mockStorage.bookmarks.push(bookmark);\r\n  return bookmark;\r\n};\r\n\r\n/**\r\n * Remove a document bookmark\r\n * @param {string} userId - User ID\r\n * @param {string} documentId - Document ID\r\n * @returns {Promise<boolean>} - Success status\r\n */\r\nexport const removeBookmark = async (userId, documentId) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 500));\r\n  \r\n  const bookmarkIndex = mockStorage.bookmarks.findIndex(\r\n    b => b.userId === userId && b.documentId === documentId\r\n  );\r\n  \r\n  if (bookmarkIndex !== -1) {\r\n    mockStorage.bookmarks.splice(bookmarkIndex, 1);\r\n    return true;\r\n  }\r\n  \r\n  return false;\r\n};\r\n\r\n/**\r\n * Get bookmarked documents for a user\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Array>} - List of bookmarked documents\r\n */\r\nexport const getBookmarkedDocuments = async (userId) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 500));\r\n  \r\n  // Get bookmark entries for this user\r\n  const bookmarks = mockStorage.bookmarks.filter(b => b.userId === userId);\r\n  \r\n  // Get the actual documents\r\n  const bookmarkedDocs = bookmarks.map(bookmark => {\r\n    const doc = mockStorage.documents.find(d => d.id === bookmark.documentId);\r\n    return doc ? { ...doc, bookmarkedAt: bookmark.createdAt } : null;\r\n  }).filter(doc => doc !== null);\r\n  \r\n  return bookmarkedDocs;\r\n};\r\n\r\n/**\r\n * Check if a document is bookmarked\r\n * @param {string} userId - User ID\r\n * @param {string} documentId - Document ID\r\n * @returns {Promise<boolean>} - Whether the document is bookmarked\r\n */\r\nexport const isDocumentBookmarked = async (userId, documentId) => {\r\n  // Simulate API delay\r\n  await new Promise(resolve => setTimeout(resolve, 300));\r\n  \r\n  return mockStorage.bookmarks.some(\r\n    b => b.userId === userId && b.documentId === documentId\r\n  );\r\n};\r\n\r\n// Generate some initial sample data\r\nconst generateSampleData = () => {\r\n  const sampleDocs = [\r\n    {\r\n      title: \"Company Annual Report 2023\",\r\n      fileType: \"pdf\",\r\n      description: \"Financial statements and overview of company performance for 2023.\",\r\n      fileSize: 2.4 * 1024 * 1024\r\n    },\r\n    {\r\n      title: \"Project Proposal: AI Integration\",\r\n      fileType: \"docx\",\r\n      description: \"Detailed proposal for integrating AI into our customer service workflows.\",\r\n      fileSize: 1.8 * 1024 * 1024\r\n    },\r\n    {\r\n      title: \"Meeting Notes - Product Team\",\r\n      fileType: \"txt\",\r\n      description: \"Notes from the weekly product team meeting discussing roadmap.\",\r\n      fileSize: 0.2 * 1024 * 1024\r\n    },\r\n    {\r\n      title: \"Technical Documentation\",\r\n      fileType: \"pdf\",\r\n      description: \"API reference and implementation guide for developers.\",\r\n      fileSize: 3.5 * 1024 * 1024\r\n    },\r\n    {\r\n      title: \"Marketing Strategy 2024\",\r\n      fileType: \"docx\",\r\n      description: \"Comprehensive marketing plan and strategy for the upcoming year.\",\r\n      fileSize: 1.2 * 1024 * 1024\r\n    }\r\n  ];\r\n\r\n  // Add sample documents\r\n  sampleDocs.forEach((doc, index) => {\r\n    const docId = `sample-doc-${index + 1}`;\r\n    mockStorage.documents.push({\r\n      id: docId,\r\n      title: doc.title,\r\n      fileName: `${doc.title.toLowerCase().replace(/\\s+/g, '-')}.${doc.fileType}`,\r\n      fileSize: doc.fileSize,\r\n      fileType: doc.fileType,\r\n      fileUrl: `https://example.com/documents/${docId}`,\r\n      uploadedBy: 'user-123',\r\n      uploadedAt: new Date(Date.now() - (index * 86400000)).toISOString(), // Each doc one day apart\r\n      path: `documents/user-123/${docId}.${doc.fileType}`,\r\n      description: doc.description\r\n    });\r\n  });\r\n\r\n  // Add some bookmarks\r\n  mockStorage.bookmarks.push({\r\n    id: 'bookmark-1',\r\n    userId: 'user-123',\r\n    documentId: 'sample-doc-1',\r\n    createdAt: new Date().toISOString()\r\n  });\r\n  \r\n  mockStorage.bookmarks.push({\r\n    id: 'bookmark-2',\r\n    userId: 'user-123',\r\n    documentId: 'sample-doc-3',\r\n    createdAt: new Date().toISOString()\r\n  });\r\n};\r\n\r\n// Initialize sample data\r\ngenerateSampleData();\r\n\r\nexport default {\r\n  uploadDocument,\r\n  getUserDocuments,\r\n  getDocumentById,\r\n  deleteDocument,\r\n  updateDocumentMetadata,\r\n  getAllDocuments,\r\n  bookmarkDocument,\r\n  removeBookmark,\r\n  getBookmarkedDocuments,\r\n  isDocumentBookmarked\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}